C251 COMPILER V5.04b,  Uart                                                                27/11/18  11:34:35  PAGE 1   


C251 COMPILER V5.04b, COMPILATION OF MODULE Uart
OBJECT MODULE PLACED IN Uart.obj
COMPILER INVOKED BY: d:\Keil\C251\BIN\C251.EXE SRC\Uart.c XSMALL BROWSE DEBUG PRINT(.\Uart.lst) OBJECT(Uart.obj) 

stmt  level    source

    1          #include "sys.h"
    2          #include "Flash.h"
    3          #include "AD.h"
    4          #include <string.h>
    5          #include "Uart.h"
    6          #include "RTC.h"
    7          #include "HT1621.h"
    8          #include "intrins.h"
    9          #include "Calculate.h"
   10          //#include "LCD.h"
   11          
   12          unsigned int j;    //发送计数
   13          uchar y;    //串口0接收计数
   14          
   15          uchar RX0[200];
   16          //uchar RX1[50];
   17          uchar TX[200];
   18          
   19          unsigned int TX_Flag;//发送标志位
   20          uint8_t Read_Flag;
   21          uchar RX1_Flag=0;//串口1接收标志
   22          #define NB_Power_ON      P0 &=~BIT3
   23          #define NB_Power_OFF     P0 |=BIT3
   24          //CRC校验部分
   25          unsigned char ucCRCHi;
   26          unsigned char ucCRCLo;
   27          const unsigned char  aucCRCHi[] = {
   28              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
   29              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
   30              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
   31              0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
   32              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
   33              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
   34              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
   35              0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
   36              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
   37              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
   38              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
   39              0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
   40              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
   41              0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
   42              0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
   43              0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
   44              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
   45              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
   46              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
   47              0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
   48              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
   49              0x00, 0xC1, 0x81, 0x40};
   50          const unsigned char aucCRCLo[] = {
   51              0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7,
   52              0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E,
   53              0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9,
   54              0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,
   55              0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
   56              0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32,
   57              0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D,
   58              0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38,
   59              0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF,
C251 COMPILER V5.04b,  Uart                                                                27/11/18  11:34:35  PAGE 2   

   60              0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
   61              0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1,
   62              0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,
   63              0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB,
   64              0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA,
   65              0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
   66              0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,
   67              0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97,
   68              0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E,
   69              0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89,
   70              0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
   71              0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83,
   72              0x41, 0x81, 0x80, 0x40};
   73          void Uart1_Read_Data(void);
   74          /*******************************************************************************
   75          * 函  数  名      : Set_DCO
   76          * 描      述      : 设置DCO时钟4MHZ 使用外部晶振
   77          * 输      入      : 无.
   78          * 返      回      : 无.
   79          *******************************************************************************/
   80          void Set_DCO(void)
   81          {
   82   1        //时钟初始化-------------------------------------                                                                     
   83   1        CLKC=0xC7;
   84   1        //CLKC2 |=BIT5;
   85   1        CLKC1 =(unsigned char)CAL0;                                   //读取主频校准值 4M
   86   1        while(!(CLKC2 & 0X80));                                               //等待主频稳定
   87   1      
   88   1      }
   89          /*******************************************************************************
   90          * 函  数  名      : Uart_Init
   91          * 描      述      : 串口初始化 2400bps 偶校验
   92          * 输      入      : 无.
   93          * 返      回      : 无.
   94          *******************************************************************************/
   95          void Uart_Init(void)
   96          {
   97   1      /*       //UART0初始化
   98   1        P5_DIR  &= ~BIT1;                                                              //p5.1输出TXD
   99   1        P5_DIR  |= BIT0;                                                               //p5.0输入RXD
  100   1        P5_SEL0 &= ~(BIT0 +BIT1);                                              //设置P5.0  P5.1为UART0 RXD TXD 
  101   1        P5_SEL1 |= BIT0 +BIT1;
  102   1        PCON |= U0BRD;                                                                 //波特率翻倍
  103   1        U0_TM =152;//230;//152;                                               //设置波特率 2400bps    
  104   1        U0_TMR &=~ UXTMR;                                                  //启动波特率发生器
  105   1        SCON = 0;//UXSM_3 + UXREN;                                             //设置串口工作方式
  106   1        */
  107   1        //UART1初始化
  108   1        P1_DIR  &= ~BIT7;                                                              //p1.7输出TXD
  109   1        P1_DIR  |= BIT6;                                                               //p1.6输入RXD
  110   1        P1_SEL0 &= ~(BIT6 +BIT7);                                              //设置P1.6  P1.7为UART1 RXD TXD 
  111   1        P1_SEL1 |= BIT6 +BIT7;
  112   1        P1_SEL2 &= ~(BIT6 +BIT7);
  113   1        PCON |= U1BRD;                                                                 //波特率翻倍
  114   1        U1_TM =230;//230;//230;                                                //设置波特率9600
  115   1        U1_TMR |= UXTMR;                                                   //启动波特率发生器
  116   1        SCON1 = UXSM_1 + UXREN;                                                //设置串口工作方式
  117   1        IPH0 |=BIT4;
  118   1        IPL0 |=BIT4;
  119   1        ES = 1;                                                                                //打开串口中断
  120   1      }
  121          /*******************************************************************************
  122          * 函  数  名      : Uart0_Init
  123          * 描      述      : 串口初始化 2400bps 偶校验
  124          * 输      入      : 无.
  125          * 返      回      : 无.
C251 COMPILER V5.04b,  Uart                                                                27/11/18  11:34:35  PAGE 3   

  126          *******************************************************************************/
  127          void Uart0_Init(void)
  128          {
  129   1      //UART0初始化
  130   1        P5_DIR  &= ~BIT1;                                                              //p5.1输出TXD
  131   1        P5_DIR  |= BIT0;                                                               //p5.0输入RXD
  132   1        P5_SEL0 &= ~(BIT0 +BIT1);                                              //设置P5.0  P5.1为UART0 RXD TXD 
  133   1        P5_SEL1 |= BIT0 +BIT1;
  134   1        PCON |= U0BRD;                                                                 //波特率翻倍
  135   1        U0_TM =152;//230;//                                           //设置波特率 2400bps    
  136   1        U0_TMR |=UXTMR;                                                    //启动波特率发生器
  137   1        SCON = UXSM_1 + UXREN;                                                 //设置串口工作方式
  138   1        IPH0 |=BIT4;
  139   1        IPL0 |=BIT4;
  140   1        ES = 1;                                                                                //打开串口中断
  141   1      }
  142          /*******************************************************************************
  143          * 函  数  名      : usMBCRC16
  144          * 描      述      : CRC校验函数
  145          * 输      入      : 无.
  146          * 返      回      : 无.
  147          *******************************************************************************/
  148          void usMBCRC16( unsigned char * pucFrame, unsigned int usLen )
  149          {
  150   1          unsigned int iIndex12;    
  151   1          ucCRCHi = 0xFF;
  152   1          ucCRCLo = 0xFF;
  153   1          while(usLen--)
  154   1          {
  155   2              iIndex12 = ucCRCLo ^ *( pucFrame++ );
  156   2              
  157   2              ucCRCLo = (unsigned char)( ucCRCHi ^ aucCRCHi[iIndex12] );
  158   2              
  159   2              ucCRCHi = aucCRCLo[iIndex12];
  160   2          }
  161   1      }
  162          /*******************************************************************************
  163          * 函  数  名      : Clear_RX
  164          * 描      述      : 清除接收缓存器
  165          * 输      入      : 0，清除RX0；1 清除RX1 
  166          * 返      回      : .
  167          *******************************************************************************/
  168          void Clear_RX(uchar n)
  169          {
  170   1        uchar i;
  171   1        if(!n)
  172   1        for(i=0;i<150;i++)
  173   1        {
  174   2          RX0[i]=0x00;
  175   2        }
  176   1      }
  177          /*******************************************************************************
  178          * 函  数  名      :  
  179          * 描      述      :  
  180          * 输      入      :     
  181          * 返      回      :  
  182          *******************************************************************************/
  183          char *strwu(const char *str1, const char *str2)
  184          {
  185   1          char *cp = (char*)str1;
  186   1          char *s1, *s2;
  187   1       
  188   1          if (!*str2)
  189   1              return((char *)str1);
  190   1       
  191   1          while (*cp)
C251 COMPILER V5.04b,  Uart                                                                27/11/18  11:34:35  PAGE 4   

  192   1          {
  193   2              s1 = cp;
  194   2              s2 = (char *)str2;
  195   2       
  196   2              while (*s1 && *s2 && !(*s1 - *s2))
  197   2                  s1++, s2++;
  198   2       
  199   2              if (!*s2)
  200   2                  return(cp);
  201   2       
  202   2              cp++;
  203   2          }
  204   1          return(NULL);
  205   1      }
  206          /*******************************************************************************
  207          * 函  数  名      : Check_cmd 
  208          * 描      述      : 字检测输入的字符，是否在相关数组中
  209          * 输      入      : 0 检查是否在RX0中；1 检查是否在RX1中   
  210          * 返      回      : 位置信息
  211          *******************************************************************************/
  212          char* Check_cmd(uchar n,char*str)
  213          {
  214   1              char *strx=0;
  215   1              if(n==0)
  216   1              strx=strwu((const char*)RX0,(const char*)str);
  217   1              return (char*)strx;
  218   1      }
  219          /*******************************************************************************
  220          * 函  数  名      : Check_Str 
  221          * 描      述      : 检测相关字符在数组中第一次出现的位置
  222          * 输      入      : 0 检查是否在RX0中；1 检查是否在RX1中   
  223          * 返      回      : 在数组中出现的位置
  224          *******************************************************************************/
  225          uchar Check_Str(char str)
  226          {
  227   1              unsigned char i;
  228   1      
  229   1              for(i=0;i<100;i++)
  230   1              {
  231   2                       if(str==RX0[i])
  232   2                       {
  233   3                              break;
  234   3                       }
  235   2              }
  236   1              return i;
  237   1      }
  238          /*******************************************************************************
  239          * 函  数  名      : Uart0_TX
  240          * 描      述      : 串口0发送触发
  241          * 输      入      : 无
  242          * 返      回      : 无.
  243          *******************************************************************************/
  244          void Uart0_TX(void)
  245          {
  246   1            j = 0;
  247   1                SBUF1=TX[j];
  248   1      }
  249          /*******************************************************************************
  250          * 函  数  名      : NB_Close
  251          * 描      述      : 模块关机，断开NB模块部分电源
  252          * 输      入      : 延迟时间
  253          * 返      回      : NULL
  254          *******************************************************************************/
  255          void NB_Close(uchar time)
  256          {
  257   1              P5_DIR  &= ~BIT1;                                
C251 COMPILER V5.04b,  Uart                                                                27/11/18  11:34:35  PAGE 5   

  258   1          P5_SEL0 &= ~BIT1; 
  259   1          P5_SEL1 &= ~BIT1;
  260   1              P1_DIR  &= ~BIT7;                                                                //p1.7输出TXD
  261   1          P1_DIR  &= ~BIT6;                                                            //p1.6输入RXD
  262   1          P1_SEL0 &= ~(BIT6 +BIT7);                                            //设置P1.6  P1.7为UART1 RXD TXD 
  263   1          P1_SEL1 &= ~(BIT6 +BIT7);
  264   1          P1_SEL2 &= ~(BIT6 +BIT7);
  265   1              P1 &=~(BIT6+BIT7);_nop_();
  266   1              P5 &=~BIT1;_nop_();_nop_(); 
  267   1              P0_DIR &=~BIT0;
  268   1              P0 |=BIT0;_nop_(); //AD监测口
  269   1              _nop_();_nop_();_nop_();_nop_();_nop_();
  270   1              Delay(5);
  271   1              NB_Power_OFF;   
  272   1              CDMA_time=time;
  273   1              while(CDMA_time);               
  274   1      }
  275          /*******************************************************************************
  276          * 函  数  名      : NB_Open
  277          * 描      述      : NB模块上电，并等待工作正常
  278          * 输      入      : time 等待返回的时间  
  279          * 返      回      : 执行结果 1 OK  0 err
  280          *******************************************************************************/
  281          uchar NB_Open(uint8 time)
  282          {
  283   1              uchar nb=0;
  284   1              NB_Power_ON; //CDMA_POWER
  285   1              CDMA_time=6;
  286   1              while(CDMA_time); //等待接收时间
  287   1              //while(1);
  288   1              strcpy((char*)TX,"AT\r\n");
  289   1          TX_Flag=4;
  290   1              y=0;Uart0_TX();
  291   1              CDMA_time=2;
  292   1              while(TX_Flag)//等待发送完成
  293   1              {
  294   2                      if(CDMA_time==0)
  295   2                              break;
  296   2              }
  297   1              while(--time)//等待接收时间
  298   1              {
  299   2                      Delay(30);
  300   2                      if(Check_cmd(0,"OK"))
  301   2                      {
  302   3                              nb=0x01;
  303   3                              break;
  304   3                      }
  305   2                      nb=0x00;
  306   2                      if(time==0) break;      
  307   2              }
  308   1              Clear_RX(0);
  309   1              nb=1;
  310   1          return nb;
  311   1      }
  312          /*******************************************************************************
  313          * 函  数  名      : NB_CSQ
  314          * 描      述      : 查询信号值
  315          * 输      入      : time 等待返回的时间  
  316          * 返      回      : 执行结果 1 OK  0 err
  317          *******************************************************************************/
  318          uchar NB_CSQ(uchar time)
  319          {
  320   1              uchar nb=0,qw; 
  321   1              strcpy((char*)TX,"AT+CSQ\r\n");
  322   1          TX_Flag=8;
  323   1              g_write_value[24]=66;
C251 COMPILER V5.04b,  Uart                                                                27/11/18  11:34:35  PAGE 6   

  324   1              y=0;Uart0_TX();
  325   1              CDMA_time=2;
  326   1              while(TX_Flag)//等待发送完成
  327   1              {
  328   2                      if(CDMA_time==0)
  329   2                              break;
  330   2              }
  331   1              while(--time)//等待接收时间
  332   1              {
  333   2                      CDMA_time=1;
  334   2                      while(CDMA_time); 
  335   2                      if(Check_cmd(0,"OK"))
  336   2                      {
  337   3                              nb=Check_Str(':');
  338   3                              qw=Check_Str(',');
  339   3                              if((qw-nb)==2)
  340   3                                              g_write_value[24]=RX0[nb+1]-0x30;
  341   3                              else if((qw-nb)==3)
  342   3                                              g_write_value[24]=(RX0[nb+1]-0x30)*10+(RX0[nb+2]-0x30);
  343   3                              if(g_write_value[24]<40 || g_write_value[24]==0)//信号值有效
  344   3                              {
  345   4                                      nb=0x01;
  346   4                                      break;//跳出循环        
  347   4                              }
  348   3                              else
  349   3                              {
  350   4                                      Clear_RX(0);
  351   4                                      TX_Flag=8;
  352   4                                      y=0;Uart0_TX();
  353   4                                      CDMA_time=2;
  354   4                                      while(TX_Flag)//等待发送完成
  355   4                                      {
  356   5                                              if(CDMA_time==0)
  357   5                                                      break;
  358   5                                      }
  359   4                              }       
  360   3                      }
  361   2                      nb=0x00;
  362   2                      if(time==0) break;      
  363   2              }
  364   1              //CDMA_time=1;
  365   1              //while(CDMA_time);
  366   1              //Clear_RX(0);
  367   1          return nb;
  368   1      }
  369          /*******************************************************************************
  370          * 函  数  名      : NB_CGATT
  371          * 描      述      : 查询模块是否附着成功
  372          * 输      入      : time 等待返回的时间  
  373          * 返      回      : 执行结果 1 OK  0 err
  374          *******************************************************************************/
  375          uchar NB_CGATT(uchar time)
  376          {
  377   1              uchar nb=0; 
  378   1              strcpy((char*)TX,"AT+CGATT?\r\n");
  379   1          TX_Flag=11;
  380   1              y=0;Uart0_TX();
  381   1              CDMA_time=2;
  382   1              while(TX_Flag)//等待发送完成
  383   1              {
  384   2                      if(CDMA_time==0)
  385   2                              break;
  386   2              }
  387   1              while(--time)//等待接收时间
  388   1              {
  389   2                      CDMA_time=1;
C251 COMPILER V5.04b,  Uart                                                                27/11/18  11:34:35  PAGE 7   

  390   2                      while(CDMA_time);
  391   2                      if(Check_cmd(0,"OK"))
  392   2                      {
  393   3                              nb=Check_Str(':');
  394   3                              nb=RX0[nb+1]-0x30;
  395   3                              if(nb==1)//附着成功
  396   3                              {
  397   4                                      break;//跳出循环        
  398   4                              }
  399   3                              else
  400   3                              {
  401   4                                      if(Check_cmd(0,"TIND"))
  402   4                                      {
  403   5                                              nb=1;
  404   5                                              break;//跳出循环
  405   5                                      }
  406   4                                      else Clear_RX(0);
  407   4                                      TX_Flag=11;
  408   4                                      y=0;Uart0_TX();
  409   4                                      CDMA_time=2;
  410   4                                      while(TX_Flag)//等待发送完成
  411   4                                      {
  412   5                                              if(CDMA_time==0)
  413   5                                                      break;
  414   5                                      }
  415   4                              }       
  416   3                      }                       
  417   2                      /*if(Check_cmd(0,"TIND"))
  418   2                      {
  419   2                              nb=1;
  420   2                              time=0;
  421   2                              break;
  422   2                      }*/             
  423   2                      nb=0x00;
  424   2                      if(time==0) break;      
  425   2              }
  426   1              Clear_RX(0);
  427   1          return nb;
  428   1      }
  429          /*******************************************************************************
  430          * 函  数  名      : NB_CEREG
  431          * 描      述      : 查询模块网络注册状态
  432          * 输      入      : time 等待返回的时间  
  433          * 返      回      : 执行结果 1 OK  0 err
  434          *******************************************************************************/
  435           uchar NB_CEREG(uchar time)
  436          {
  437   1              uchar nb=0; 
  438   1              strcpy((char*)TX,"AT+CGPADDR\r\n");
  439   1          TX_Flag=12;
  440   1              y=0;Uart0_TX();
  441   1              CDMA_time=2;
  442   1              while(TX_Flag)//等待发送完成
  443   1              {
  444   2                      if(CDMA_time==0)
  445   2                              break;
  446   2              }
  447   1              while(--time)//等待接收时间
  448   1              {
  449   2                      CDMA_time=1;
  450   2                      while(CDMA_time);
  451   2                      if(Check_cmd(0,"OK"))
  452   2                      {
  453   3                              nb=Check_Str(':');
  454   3                              if(RX0[nb+3]+RX0[nb+4])
  455   3                              {
C251 COMPILER V5.04b,  Uart                                                                27/11/18  11:34:35  PAGE 8   

  456   4                                      nb=1;
  457   4                                      break;//跳出循环        
  458   4                              }
  459   3                              else
  460   3                              {
  461   4                                      Clear_RX(0);
  462   4                                      TX_Flag=12;
  463   4                                      y=0;Uart0_TX();
  464   4                                      CDMA_time=2;
  465   4                                      while(TX_Flag)//等待发送完成
  466   4                                      {
  467   5                                              if(CDMA_time==0)
  468   5                                                      break;
  469   5                                      }
  470   4                              }       
  471   3                      }
  472   2                      nb=0x00;
  473   2                      if(time==0) break;      
  474   2              }
  475   1              Clear_RX(0);
  476   1          return nb;
  477   1      }  
  478          /*******************************************************************************
  479          * 函  数  名      : NB_CMEE
  480          * 描      述      : 设置错误返回
  481          * 输      入      : time 等待返回的时间  
  482          * 返      回      : 执行结果 1 OK  0 err
  483          AT+CMEE=1\r\n
  484          *******************************************************************************/
  485          uchar NB_CMEE(uint8 time)
  486          {
  487   1              uchar nb=0;
  488   1              strcpy((char*)TX,"AT+MLWNMI=1\r\n");
  489   1          TX_Flag=13;
  490   1              y=0;Uart0_TX();
  491   1              CDMA_time=2;
  492   1              while(TX_Flag)//等待发送完成
  493   1              {
  494   2                      if(CDMA_time==0)
  495   2                              break;
  496   2              }
  497   1              while(--time)//等待接收时间
  498   1              {
  499   2                      Delay(50);
  500   2                      if(Check_cmd(0,"OK"))
  501   2                      {
  502   3                              nb=0x01;
  503   3                              break;
  504   3                      }
  505   2                      nb=0x00;
  506   2                      if(time==0) break;      
  507   2              }
  508   1              Clear_RX(0);
  509   1          return nb;
  510   1      }
  511          /*******************************************************************************
  512          * 函  数  名      : NB_CELL_RESELECTION
  513          * 描      述      : 设置小区重选
  514          * 输      入      : time 等待返回的时间  
  515          * 返      回      : 执行结果 1 OK  0 err
  516          AT+NCONFIG=CELL_RESELECTION,TRUE
  517          *******************************************************************************/
  518          /*uchar NB_CELL_RESELECTION(uint8 time)
  519          {
  520                  uchar nb=0;
  521                  strcpy((char*)TX,"AT+CMEE=1\r\n");
C251 COMPILER V5.04b,  Uart                                                                27/11/18  11:34:35  PAGE 9   

  522              TX_Flag=11;
  523                  y=0;Uart0_TX();
  524                  CDMA_time=2;
  525                  while(TX_Flag)//等待发送完成
  526                  {
  527                          if(CDMA_time==0)
  528                                  break;
  529                  }
  530                  while(--time)//等待接收时间
  531                  {
  532                          Delay(50);
  533                          if(Check_cmd(0,"OK"))
  534                          {
  535                                  nb=0x01;
  536                                  break;
  537                          }
  538                          nb=0x00;
  539                          if(time==0) break;      
  540                  }
  541                  /*Clear_RX(0);
  542                  strcpy((char*)TX,"AT+NEARFCN=0,0\r\n");
  543              TX_Flag=16;
  544                  y=0;Uart0_TX();
  545                  CDMA_time=2;
  546                  while(TX_Flag)//等待发送完成
  547                  {
  548                          if(CDMA_time==0)
  549                                  break;
  550                  }
  551                  while(--time)//等待接收时间
  552                  {
  553                          Delay(50);
  554                          if(Check_cmd(0,"OK"))
  555                          {
  556                                  nb=0x01;
  557                                  break;
  558                          }
  559                          nb=0x00;
  560                          if(time==0) break;      
  561                  }*/
  562          /*      Clear_RX(0);
  563              return nb;
  564          
  565          } */
  566          /*******************************************************************************
  567          * 函  数  名      : NB_CFUN
  568          * 描      述      : 射频功能操作
  569          * 输      入      : n 0 关闭射频 1  打开射频 time 等待返回的时间  
  570          * 返      回      : 执行结果 1 OK  0 err
  571          *******************************************************************************/
  572          uchar NB_CFUN(uchar n,uchar time)
  573          {
  574   1              uchar nb=0;
  575   1              strcpy((char*)TX,"AT+CFUN=");
  576   1              if(n) TX[8]=0x31;
  577   1              else  TX[8]=0x30;
  578   1              TX[9]=0x0D;
  579   1              TX[10]=0x0A;
  580   1          TX_Flag=11;
  581   1              y=0;Uart0_TX();
  582   1              CDMA_time=2;
  583   1              while(TX_Flag)//等待发送完成
  584   1              {
  585   2                      if(CDMA_time==0)
  586   2                              break;
  587   2              }
C251 COMPILER V5.04b,  Uart                                                                27/11/18  11:34:35  PAGE 10  

  588   1              CDMA_time=time;
  589   1              while(CDMA_time)//等待接收时间
  590   1              {
  591   2                      Delay(4000);
  592   2                      if(Check_cmd(0,"OK"))
  593   2                      {
  594   3                              nb=0x01;
  595   3                              break;
  596   3                      }
  597   2                      if(Check_cmd(0,"ERR"))
  598   2                      {
  599   3                              Clear_RX(0);
  600   3                              TX_Flag=11;
  601   3                              y=0;Uart0_TX();
  602   3                              while(TX_Flag)//等待发送完成
  603   3                              {
  604   4                                      if(CDMA_time==0)
  605   4                                              break;
  606   4                              }                       
  607   3                      }
  608   2                      nb=0x00;
  609   2                      if(CDMA_time==0) break; 
  610   2              }
  611   1              Clear_RX(0);
  612   1          return nb;
  613   1      }
  614          /*******************************************************************************
  615          * 函  数  名      : NB_IoT_IP
  616          * 描      述      : IOT平台地址
  617          * 输      入      : time 等待返回的时间  
  618          * 返      回      : 执行结果 1 OK  0 err
  619          AT+NCDP=117.60.157.137,5683
  620          AT+NCDP=180.101.147.115,5683
  621          *******************************************************************************/
  622          uchar NB_IoT_IP(uint8 time)
  623          {
  624   1              uchar nb=0;
  625   1              strcpy((char*)TX,"AT+NCDP=117.60.157.137,5683\r\n");
  626   1          TX_Flag=29;
  627   1              y=0;Uart0_TX();
  628   1              CDMA_time=2;
  629   1              while(TX_Flag)//等待发送完成
  630   1              {
  631   2                      if(CDMA_time==0)
  632   2                              break;
  633   2              }
  634   1              while(--time)//等待接收时间
  635   1              {
  636   2                      Delay(50);
  637   2                      if(Check_cmd(0,"OK"))
  638   2                      {
  639   3                              nb=0x01;
  640   3                              break;
  641   3                      }
  642   2                      nb=0x00;
  643   2                      if(time==0) break;              
  644   2              }
  645   1              Clear_RX(0);
  646   1          return nb;
  647   1      }
  648          /*******************************************************************************
  649          * 函  数  名      : NB_IoT_123
  650          * 描      述      : 读取IOT平台地址
  651          * 输      入      : time 等待返回的时间  
  652          * 返      回      : 执行结果 1 OK  0 err
  653          AT+NCDP=117.60.157.137,5683
C251 COMPILER V5.04b,  Uart                                                                27/11/18  11:34:35  PAGE 11  

  654          AT+NCDP=180.101.147.115,5683
  655          *******************************************************************************/
  656          uchar NB_IoT_123(uint8 time)
  657          {
  658   1              uchar nb=0;
  659   1              strcpy((char*)TX,"AT+NCDP?\r\n");
  660   1          TX_Flag=10;
  661   1              y=0;Uart0_TX();
  662   1              CDMA_time=2;
  663   1              while(TX_Flag)//等待发送完成
  664   1              {
  665   2                      if(CDMA_time==0)
  666   2                              break;
  667   2              }
  668   1              while(--time)//等待接收时间
  669   1              {
  670   2                      Delay(50);
  671   2                      if(Check_cmd(0,"OK"))
  672   2                      {
  673   3                              nb=0x01;
  674   3                              break;
  675   3                      }
  676   2                      nb=0x00;
  677   2                      if(time==0) break;              
  678   2              }
  679   1              Clear_RX(0);
  680   1          return nb;
  681   1      }
  682          /*******************************************************************************
  683          * 函  数  名      : NB_IoT_124
  684          * 描      述      : AT 指令重启模组
  685          * 输      入      : time 等待返回的时间  
  686          * 返      回      : 执行结果 1 OK  0 err
  687          AT+NCDP=117.60.157.137,5683
  688          AT+NCDP=180.101.147.115,5683
  689          *******************************************************************************/
  690          uchar NB_IoT_124(uchar time)
  691          {
  692   1              uchar nb=0;
  693   1              strcpy((char*)TX,"AT+NRB\r\n");
  694   1          TX_Flag=8;
  695   1              y=0;Uart0_TX();
  696   1              CDMA_time=2;
  697   1              while(TX_Flag)//等待发送完成
  698   1              {
  699   2                      if(CDMA_time==0)
  700   2                              break;
  701   2              }
  702   1              while(--time)//等待接收时间
  703   1              {
  704   2                      CDMA_time=1;
  705   2                      while(CDMA_time);
  706   2                      if(Check_cmd(0,"OK"))
  707   2                      {
  708   3                              nb=0x01;
  709   3                              break;
  710   3                      }
  711   2                      nb=0x00;
  712   2                      if(time==0) break;              
  713   2              }
  714   1              Clear_RX(0);
  715   1          return nb;
  716   1      }
  717          /*******************************************************************************
  718          * 函  数  名      : NB_CGA 
  719          * 描      述      : 进行终端入网
C251 COMPILER V5.04b,  Uart                                                                27/11/18  11:34:35  PAGE 12  

  720          * 输      入      : time 等待返回的时间  
  721          * 返      回      : 执行结果 1 OK  0 err
  722          *******************************************************************************/
  723          /*uchar NB_CGA(uchar time)
  724          {
  725                  uchar nb=0;
  726                  strcpy((char*)TX,"AT+CGATT=1\r\n");
  727              TX_Flag=12;
  728                  y=0;Uart0_TX();
  729                  CDMA_time=2;
  730                  while(TX_Flag)//等待发送完成
  731                  {
  732                          if(CDMA_time==0)
  733                                  break;
  734                  }
  735                  CDMA_time=time;
  736                  while(CDMA_time)//等待接收时间
  737                  {
  738                          CDMA_Wait=0;
  739                          while(CDMA_Wait<1);
  740                          if(Check_cmd(0,"OK"))
  741                          {
  742                                  nb=0x01;
  743                                  break;
  744                          }
  745                      if(Check_cmd(0,"ERR"))
  746                          {
  747                                  Clear_RX(0);
  748                                  TX_Flag=12;
  749                                  y=0;Uart0_TX();
  750                                  while(TX_Flag)//等待发送完成
  751                                  {
  752                                          if(CDMA_time==0)
  753                                                  break;
  754                                  }                       
  755                          }
  756                          nb=0x00;
  757                          if(CDMA_time==0) break;         
  758                  }
  759                  Clear_RX(0);
  760              return nb;
  761          } */
  762          /*******************************************************************************
  763          * 函  数  名      : NB_NUESTATS 
  764          * 描      述      : 查询模块状态
  765          * 输      入      : time 等待返回的时间  
  766          * 返      回      : 1 一致  0 不一致
  767          +NCDP:117.60.157.137,5683
  768          
  769          *******************************************************************************/
  770          uchar NB_NUESTATS(uint8 time)
  771           {
  772   1              uchar nb=0,i,a;
  773   1              strcpy((char*)TX,"AT+NUESTATS\r\n");
  774   1          TX_Flag=13;
  775   1              y=0;Uart0_TX();
  776   1              CDMA_time=2;
  777   1              while(TX_Flag)//等待发送完成
  778   1              {
  779   2                      if(CDMA_time==0)
  780   2                              break;
  781   2              }
  782   1              CDMA_time=time;
  783   1              while(CDMA_time)//等待接收时间
  784   1              {
  785   2                      Delay(50);
C251 COMPILER V5.04b,  Uart                                                                27/11/18  11:34:35  PAGE 13  

  786   2                      if(Check_cmd(0,"RSRQ"))
  787   2                      {
  788   3                              //SNR
  789   3                              for(i=0;i<200;i++)
  790   3                              {
  791   4                                      if(RX0[i]=='R' && RX0[i+1]==':')
  792   4                                      {
  793   5                                              break;
  794   5                                      }
  795   4                              }
  796   3                              a=i+2;
  797   3                              if(RX0[a]>0x39 || RX0[a]<0x30)//信号值异常
  798   3                              {
  799   4                                      C_DATA[49]=0XFF;
  800   4                                      C_DATA[50]=0XFF;        
  801   4                              }
  802   3                              else//信号值不为负
  803   3                              {
  804   4                                      for(i=0;i<10;i++)
  805   4                                      {
  806   5                                              if(RX0[i+a]==0x0D) break;//查询结束符
  807   5                                      }
  808   4                                      if(i==1)
  809   4                                      {
  810   5                                              C_DATA[49]=0x00;
  811   5                                              C_DATA[50]=RX0[a]-0x30;
  812   5                                      }
  813   4                                      else if(i==2)
  814   4                                      {
  815   5                                              C_DATA[49]=0x00;
  816   5                                              C_DATA[50]=(RX0[a]-0x30)*16+RX0[a+1]-0x30;
  817   5                                      }
  818   4                                      else if(i==3)
  819   4                                      {
  820   5                                              C_DATA[49]=RX0[a]-0x30;
  821   5                                              C_DATA[50]=(RX0[a+1]-0x30)*16+RX0[a+2]-0x30;    
  822   5                                      }                                       
  823   4                              }
  824   3                              //PCI
  825   3                              for(i=0;i<200;i++)
  826   3                              {
  827   4                                      if(RX0[i]=='P' && RX0[i+1]=='C' && RX0[i+2]=='I' && RX0[i+3]==':' )
  828   4                                      {
  829   5                                              break;
  830   5                                      }
  831   4                              }
  832   3                              a=i+4;
  833   3                              for(i=0;i<10;i++)
  834   3                              {
  835   4                                      if(RX0[i+a]==0x0D) break;//查询结束符
  836   4                              }
  837   3                              if(i==1)
  838   3                              {
  839   4                                      C_DATA[51]=0x00;
  840   4                                      C_DATA[52]=RX0[a]-0x30;
  841   4                              }
  842   3                              else if(i==2)
  843   3                              {
  844   4                                      C_DATA[51]=0x00;
  845   4                                      C_DATA[52]=(RX0[a]-0x30)*16+RX0[a+1]-0x30;
  846   4                              }
  847   3                              else if(i==3)
  848   3                              {
  849   4                                      C_DATA[51]=RX0[a]-0x30;
  850   4                                      C_DATA[52]=(RX0[a+1]-0x30)*16+RX0[a+2]-0x30;    
  851   4                              }                                       
C251 COMPILER V5.04b,  Uart                                                                27/11/18  11:34:35  PAGE 14  

  852   3                              nb=0x01;
  853   3                              break;
  854   3                      }
  855   2                      nb=0x00;
  856   2                      if(CDMA_time==0) break;         
  857   2              }
  858   1              Clear_RX(0);
  859   1          return nb;
  860   1      }
  861          /*******************************************************************************
  862          * 函  数  名      : NB_CIMI 
  863          * 描      述      : 查询模块状态
  864          * 输      入      : time 等待返回的时间  
  865          * 返      回      : 1 一致  0 不一致
  866          +NCDP:117.60.157.137,5683
  867          
  868          *******************************************************************************/
  869          uchar NB_CIMI(uint8 time)
  870           {
  871   1              uchar nb=0,i,a;
  872   1              strcpy((char*)TX,"AT+CIMI\r\n");
  873   1          TX_Flag=9;
  874   1              y=0;Uart0_TX();
  875   1              CDMA_time=2;
  876   1              while(TX_Flag)//等待发送完成
  877   1              {
  878   2                      if(CDMA_time==0)
  879   2                              break;
  880   2              }
  881   1              CDMA_time=time;
  882   1              while(CDMA_time)//等待接收时间
  883   1              {
  884   2                      Delay(50);
  885   2                      if(Check_cmd(0,"OK"))
  886   2                      {
  887   3                              for(i=0;i<200;i++)
  888   3                              {
  889   4                                      if(RX0[i]==0x4F && RX0[i+1]==0x4B)
  890   4                                      {
  891   5                                              break;
  892   5                                      }
  893   4                              }
  894   3                              a=i-19;
  895   3                              for(i=0;i<15;i++)
  896   3                              {
  897   4                                      C_DATA[34+i]=RX0[a+i];
  898   4                              }                                       
  899   3                              nb=0x01;
  900   3                              break;
  901   3                      }
  902   2                      nb=0x00;
  903   2                      if(CDMA_time==0) break;         
  904   2              }
  905   1              Clear_RX(0);
  906   1          return nb;
  907   1      }
  908          /*******************************************************************************
  909          * 函  数  名      : NB_NMGS 
  910          * 描      述      : 确认终端可以进行数据发送
  911          * 输      入      : time 等待返回的时间  
  912          * 返      回      : 执行结果 1 OK  0 err
  913          *******************************************************************************/
  914          uchar NB_NMGS(uchar time)
  915          {
  916   1              uchar nb=0;
  917   1              //发送一次数据 验证是否连接平台成功
C251 COMPILER V5.04b,  Uart                                                                27/11/18  11:34:35  PAGE 15  

  918   1              strcpy((char*)TX,"AT+MLWULDATA=4,AAAA0000\r\n");
  919   1          TX_Flag=25;
  920   1              y=0;Uart0_TX();
  921   1              CDMA_time=2;
  922   1              while(TX_Flag)//等待发送完成
  923   1              {
  924   2                      if(CDMA_time==0)
  925   2                              break;
  926   2              }
  927   1              //CDMA_time=time;
  928   1              while(--time)//等待接收时间
  929   1              {
  930   2                      CDMA_time=1;
  931   2                      while(CDMA_time);
  932   2                      if(Check_cmd(0,"OK"))
  933   2                      {
  934   3                              nb=0x01;
  935   3                              break;
  936   3                      }
  937   2                      if(Check_cmd(0,"ERR"))
  938   2                      {
  939   3                              Clear_RX(0);
  940   3                          TX_Flag=25;
  941   3                              y=0;Uart0_TX();
  942   3                              while(TX_Flag)//等待发送完成
  943   3                              {
  944   4                                      if(CDMA_time==0)
  945   4                                              break;
  946   4                              }                       
  947   3                      }
  948   2                      nb=0x00;
  949   2                      if(time==0) break;              
  950   2              }
  951   1              Clear_RX(0);
  952   1              if(nb)//查询是否处于发送状态
  953   1              {
  954   2                      strcpy((char*)TX,"AT+MLWMSTATUS?\r\n");
  955   2                  TX_Flag=16;
  956   2                      y=0;Uart0_TX();
  957   2                      CDMA_time=2;
  958   2                      while(TX_Flag)//等待发送完成
  959   2                      {
  960   3                              if(CDMA_time==0)
  961   3                                      break;
  962   3                      }
  963   2                      time=500;
  964   2                      while(--time)//等待接收时间
  965   2                      {
  966   3                              Delay(15);
  967   3                              if(Check_cmd(0,"ENABLED"))
  968   3                              {
  969   4                                      nb=0x01;
  970   4                                      break;
  971   4                              }
  972   3                              nb=0x00;
  973   3                              if(time==0) break;              
  974   3                      }       
  975   2              }
  976   1               Clear_RX(0);
  977   1          return nb;
  978   1      }
  979          /*******************************************************************************
  980          * 函  数  名      : NB_eDRX 
  981          * 描      述      : 关闭eDRX
  982          * 输      入      : time 等待返回的时间  
  983          * 返      回      : 执行结果 1 OK  0 err
C251 COMPILER V5.04b,  Uart                                                                27/11/18  11:34:35  PAGE 16  

  984          *******************************************************************************/
  985          /*uchar NB_eDRX(uchar time)
  986          {
  987                  uchar nb=0;
  988                  strcpy((char*)TX,"AT+CEDRXS=0,5,");
  989                  TX[14]=0x22;
  990                  TX[15]=0x30;
  991                  TX[16]=0x31;
  992                  TX[17]=0x30;
  993                  TX[18]=0x31;
  994                  TX[19]=0x22;
  995                  TX[20]=0x0D;
  996                  TX[21]=0x0A;
  997              TX_Flag=22;
  998                  y=0;Uart0_TX();
  999                  CDMA_time=2;
 1000                  while(TX_Flag)//等待发送完成
 1001                  {
 1002                          if(CDMA_time==0)
 1003                                  break;
 1004                  }
 1005                  CDMA_time=time;
 1006                  while(CDMA_time)//等待接收时间
 1007                  {
 1008                          Delay(50);
 1009                          if(Check_cmd(0,"OK"))
 1010                          {
 1011                                  nb=0x01;
 1012                                  break;
 1013                          }
 1014                          nb=0x00;
 1015                          if(CDMA_time==0) break;         
 1016                  }
 1017                  Clear_RX(0);
 1018              return nb;
 1019          }*/
 1020          /*******************************************************************************
 1021          * 函  数  名      : NB_PSM 
 1022          * 描      述      : 关闭PSM
 1023          * 输      入      : time 等待返回的时间  
 1024          * 返      回      : 执行结果 1 OK  0 err
 1025          *******************************************************************************/
 1026          /*uchar NB_PSM(uchar time)
 1027          {
 1028                  uchar nb=0;
 1029                  strcpy((char*)TX,"AT+CPSMS=0\r\n");
 1030              TX_Flag=12;
 1031                  y=0;Uart0_TX();
 1032                  CDMA_time=2;
 1033                  while(TX_Flag)//等待发送完成
 1034                  {
 1035                          if(CDMA_time==0)
 1036                                  break;
 1037                  }
 1038                  while(--time)//等待接收时间
 1039                  {
 1040                          Delay(50);
 1041                          if(Check_cmd(0,"OK"))
 1042                          {
 1043                                  nb=0x01;
 1044                                  break;
 1045                          }
 1046                          nb=0x00;
 1047                          if(time==0) break;              
 1048                  }
 1049                  Clear_RX(0);
C251 COMPILER V5.04b,  Uart                                                                27/11/18  11:34:35  PAGE 17  

 1050              return nb;
 1051          }*/
 1052          /*******************************************************************************
 1053          * 函  数  名      : NB_NCSEARFCN
 1054          * 描      述      : 清频
 1055          * 输      入      : time 等待返回的时间 单位秒  
 1056          * 返      回      : 状态值：1 ok  0 err
 1057          *******************************************************************************/
 1058          uchar NB_NCSEARFCN(uchar time)
 1059           {
 1060   1              uchar nb=0;
 1061   1              strcpy((char*)TX,"AT+NCSEARFCN\r\n");
 1062   1          TX_Flag=14;
 1063   1              y=0;Uart0_TX();
 1064   1              CDMA_time=2;
 1065   1              while(TX_Flag)//等待发送完成
 1066   1              {
 1067   2                      if(CDMA_time==0)
 1068   2                              break;
 1069   2              }
 1070   1              CDMA_time=time;
 1071   1              while(CDMA_time)//等待接收时间
 1072   1              {
 1073   2                      Delay(50);
 1074   2                      if(Check_cmd(0,"OK"))
 1075   2                      {       
 1076   3                              nb=0x01;
 1077   3                              break;
 1078   3                      }
 1079   2                      nb=0x00;
 1080   2                      if(CDMA_time==0) break; 
 1081   2              }
 1082   1              Clear_RX(0);
 1083   1          return nb;
 1084   1      }
 1085          /*******************************************************************************
 1086          * 函  数  名      : NB_IoT
 1087          * 描      述      : 设置平台连接参数
 1088          * 输      入      : qwe 需要发送的数据起始地址；n 发送的数据位数；time 等待返回的时间 单位秒  
 1089          * 返      回      : 状态值：1 ok  0 err
 1090          *******************************************************************************/
 1091          uchar NB_IoT(void)
 1092          {
 1093   1              uchar nb=0;
 1094   1              //NB_CELL_RESELECTION(500);
 1095   1              /*      if(NB_CFUN(0,20))//关闭射频
 1096   1                       {                      
 1097   1                              NB_IoT_IP(600);
 1098   1                              CDMA_time=2;
 1099   1                              while(CDMA_time);//等待接收时间
 1100   1                              */
 1101   1                              NB_IoT_123(500);
 1102   1                              CDMA_time=1;
 1103   1                              while(CDMA_time);//等待接收时间
 1104   1                              NB_CMEE(500);
 1105   1                              CDMA_time=1;
 1106   1                              while(CDMA_time);//等待接收时间
 1107   1                      /*NB_CELL_RESELECTION(500);
 1108   1                              //if(NB_eDRX(10))//关闭eDRX
 1109   1                              //{
 1110   1                                      //NB_PSM(500);//关闭PSM
 1111   1                                      //CDMA_time=1;
 1112   1                                      //while(CDMA_time);//等待接收时间
 1113   1                                      //if(NB_IoT_IP(600))//设置IoT IP
 1114   1                                      //{     
 1115   1                                      //      CDMA_time=3;
C251 COMPILER V5.04b,  Uart                                                                27/11/18  11:34:35  PAGE 18  

 1116   1                              //              while(CDMA_time);//等待接收时间
 1117   1                                      //      if(NB_CFUN(1,20))//打开射频
 1118   1                                      //      {                                       
 1119   1                                      //              if(NB_CGA(20))//允许终端入网
 1120   1                                      //              { 
 1121   1                                      //                      CDMA_time=2;
 1122   1                                      //                      while(CDMA_time);//等待接收时间
 1123   1                                      */                      
 1124   1                                                              nb=1;   
 1125   1                                              //      }
 1126   1                                      //      }
 1127   1                                      //}                             
 1128   1                              //}     */
 1129   1      
 1130   1                       //}            
 1131   1              //else nb=1;
 1132   1              return nb;
 1133   1      }
 1134          /*******************************************************************************
 1135          * 函  数  名      : NB_NSOST
 1136          * 描      述      : 发送数据
 1137          * 输      入      : qwe 需要发送的数据起始地址；n 发送的数据位数；time 等待返回的时间 单位秒  
 1138          * 返      回      : 状态值：1 ok  0 err
 1139          AT+NMGS=5,00012E1F63
 1140          *******************************************************************************/
 1141          uchar NB_NSOST(uchar* qwe,unsigned short n,uchar time)
 1142          {
 1143   1              uchar nb=0,s,a,b;//c,d,e,f;
 1144   1              //NB_NSOCR(1);
 1145   1              strcpy((char*)TX,"AT+MLWULDATA=");_nop_();
 1146   1              if(n>99)
 1147   1              {
 1148   2                      TX[13]=n/100+0x30;
 1149   2                      TX[14]=(n%100)/10+0x30;
 1150   2                      TX[15]=n%10+0x30;
 1151   2                      nb=16;  
 1152   2              }
 1153   1              else if(n>9)
 1154   1              {
 1155   2                      TX[13]=n/10+0x30;
 1156   2                      TX[14]=n%10+0x30;
 1157   2                      nb=15;
 1158   2              }
 1159   1              else 
 1160   1              {
 1161   2                      TX[13]=n+0x30;
 1162   2                      nb=14;
 1163   2              }
 1164   1              TX[nb]=0x2C;
 1165   1              //协议加载，待发送
 1166   1              for(s=0;s<n;s++)
 1167   1              {
 1168   2                  a=qwe[s]/16;
 1169   2                      b=qwe[s]%16;
 1170   2                      if(a>9)
 1171   2                      {
 1172   3                              if(a==10) a=0x41;
 1173   3                              if(a==11) a=0x42;
 1174   3                              if(a==12) a=0x43;
 1175   3                              if(a==13) a=0x44;
 1176   3                              if(a==14) a=0x45;
 1177   3                              if(a==15) a=0x46;
 1178   3                      }
 1179   2                      else a=a+0x30;
 1180   2                      if(b>9)
 1181   2                      {
C251 COMPILER V5.04b,  Uart                                                                27/11/18  11:34:35  PAGE 19  

 1182   3                      if(b==10) b=0x41;
 1183   3                      if(b==11) b=0x42;
 1184   3                      if(b==12) b=0x43;
 1185   3                      if(b==13) b=0x44;
 1186   3                      if(b==14) b=0x45;
 1187   3                      if(b==15) b=0x46;
 1188   3                      }
 1189   2                      else b=b+0x30;
 1190   2                      TX[nb+1+2*s]=a;
 1191   2                      TX[nb+2+2*s]=b;
 1192   2              }
 1193   1              TX[nb+1+2*n]=0x0D;
 1194   1              TX[nb+2+2*n]=0x0A;
 1195   1              TX_Flag=nb+3+2*n;
 1196   1              Uart0_TX();
 1197   1              CDMA_time=2;
 1198   1              while(TX_Flag)//等待发送完成
 1199   1              {
 1200   2                      if(CDMA_time==0)
 1201   2                              break;
 1202   2              }
 1203   1              y=0;
 1204   1              CDMA_time=time;
 1205   1              while(--time)//等待接收时间
 1206   1              {
 1207   2                      CDMA_time=1;
 1208   2                      while(CDMA_time);
 1209   2                      if(Check_cmd(0,"OK")) 
 1210   2                      {
 1211   3                          nb=0x01;
 1212   3                          break;
 1213   3                      }
 1214   2                      else if(Check_cmd(0,"ERR"))
 1215   2                      {
 1216   3                              TX_Flag=nb+3+2*n;
 1217   3                              y=0;Uart0_TX();
 1218   3                              while(TX_Flag);//等待发送完成                   
 1219   3                      }
 1220   2                      else nb=0x00;
 1221   2                      if(CDMA_time==0) break; 
 1222   2              }
 1223   1              Clear_RX(0);
 1224   1          return nb;  
 1225   1      }
 1226          /*******************************************************************************
 1227          * 函  数  名      : Data_deal
 1228          * 描      述      : NB模块上电，并等待工作正常
 1229          * 输      入      : cs 协议编码，num 发送数据数量  
 1230          * 返      回      : 执行结果 1 OK  0 err
 1231          *******************************************************************************/
 1232          void Data_deal(uint8_t cs,unsigned short num)
 1233          {
 1234   1          unsigned short i;
 1235   1              C_DATA[0]=0x1B;
 1236   1              C_DATA[1]=0x06;
 1237   1              C_DATA[2]=0x66;//g_write_value[0];
 1238   1              C_DATA[3]=0x66;//g_write_value[1];
 1239   1          C_DATA[4]=0x66;//g_write_value[2];
 1240   1              C_DATA[5]=0x66;//g_write_value[3];
 1241   1              switch(cs)
 1242   1              {
 1243   2              case 0://心跳包
 1244   2                      C_DATA[6]=0xA1;
 1245   2                      C_DATA[7]=g_write_value[0];
 1246   2                      C_DATA[8]=g_write_value[1];
 1247   2                      C_DATA[9]=g_write_value[2];
C251 COMPILER V5.04b,  Uart                                                                27/11/18  11:34:35  PAGE 20  

 1248   2                      C_DATA[10]=g_write_value[3];
 1249   2                      C_DATA[11]=g_write_value[4];
 1250   2                      C_DATA[12]=g_write_value[5];
 1251   2                      C_DATA[13]=g_write_value[6];
 1252   2                      C_DATA[14]=0x00;
 1253   2                      C_DATA[15]=0x00;
 1254   2                      usMBCRC16(&C_DATA[2],14);
 1255   2                      C_DATA[16]=ucCRCLo;
 1256   2                      C_DATA[17]=ucCRCHi;
 1257   2                      C_DATA[18]=0x68;
 1258   2                      C_DATA[19]=0x16;
 1259   2                      break;
 1260   2              case 1://数据上传
 1261   2                      //电压采集
 1262   2                      ADC_Read();
 1263   2                      //信号强度采集
 1264   2                      g_write_value[23] =(g_write_value[23]&0xE0)+(g_write_value[24]&0x1F);
 1265   2                      C_DATA[6]=0xA2;
 1266   2                      C_DATA[7]=g_write_value[0];
 1267   2                      C_DATA[8]=g_write_value[1];
 1268   2                      C_DATA[9]=g_write_value[2];
 1269   2                      C_DATA[10]=g_write_value[3];
 1270   2                      C_DATA[11]=g_write_value[4];
 1271   2                      C_DATA[12]=g_write_value[5];
 1272   2                      C_DATA[13]=g_write_value[6];
 1273   2                      C_DATA[14]=0x00;
 1274   2                      C_DATA[15]=0x25;
 1275   2                      //用户总用水量
 1276   2                      C_DATA[16]=g_write_value[7];
 1277   2                      C_DATA[17]=g_write_value[8];
 1278   2                      C_DATA[18]=g_write_value[9];
 1279   2                      //表上时间
 1280   2                      C_DATA[19]=g_write_value[13];
 1281   2                      C_DATA[20]=g_write_value[14];
 1282   2                      C_DATA[21]=g_write_value[15];
 1283   2                      C_DATA[22]=g_write_value[16];
 1284   2                      C_DATA[23]=g_write_value[17];
 1285   2                      C_DATA[24]=g_write_value[18];
 1286   2                      C_DATA[25]=g_write_value[19];
 1287   2                      //上传间隔
 1288   2                      C_DATA[26]=g_write_value[34];
 1289   2                      //上传时间
 1290   2                      C_DATA[27]=g_write_value[35];//g_write_value[120];
 1291   2                      C_DATA[28]=g_write_value[36];//g_write_value[121];
 1292   2                      //脉冲当量
 1293   2                      C_DATA[29]=g_write_value[27];
 1294   2                      //电池电压
 1295   2                      C_DATA[30]=g_write_value[38];
 1296   2                      //表状态
 1297   2                      C_DATA[31]=g_write_value[22];
 1298   2                      C_DATA[32]=g_write_value[23];
 1299   2                      //已冻结数据条数
 1300   2                      C_DATA[33]=g_write_value[20];
 1301   2                      //IMSI号 15字节 48
 1302   2                      //NB_CIMI(2);
 1303   2                      //SNR 值 2字节 50
 1304   2                      //NB_NUESTATS(2);
 1305   2                      //PCI 值 2字节 51 52
 1306   2      
 1307   2                      //校验位
 1308   2                      usMBCRC16(&C_DATA[2],51);
 1309   2                      C_DATA[53]=ucCRCLo;
 1310   2                      C_DATA[54]=ucCRCHi;
 1311   2                      //字尾
 1312   2                      C_DATA[55]=0X68;
 1313   2                      C_DATA[56]=0X16;
C251 COMPILER V5.04b,  Uart                                                                27/11/18  11:34:35  PAGE 21  

 1314   2                      break;
 1315   2              case 3://写指令返回
 1316   2                      C_DATA[6]=TX_Flag;
 1317   2                      C_DATA[7]=g_write_value[0];
 1318   2                      C_DATA[8]=g_write_value[1];
 1319   2                      C_DATA[9]=g_write_value[2];
 1320   2                      C_DATA[10]=g_write_value[3];
 1321   2                      C_DATA[11]=g_write_value[4];
 1322   2                      C_DATA[12]=g_write_value[5];
 1323   2                      C_DATA[13]=g_write_value[6];
 1324   2                      C_DATA[14]=0x00;
 1325   2                      C_DATA[15]=0x01;
 1326   2                      C_DATA[16]=Read_Flag;
 1327   2                      usMBCRC16(&C_DATA[2],15);
 1328   2                      C_DATA[17]=ucCRCLo;
 1329   2                      C_DATA[18]=ucCRCHi;
 1330   2                      C_DATA[19]=0X68;
 1331   2                      C_DATA[20]=0X16;
 1332   2                      break;
 1333   2              case 4://参数读取
 1334   2                      C_DATA[6]=0xA6;
 1335   2                      C_DATA[7]=g_write_value[0];
 1336   2                      C_DATA[8]=g_write_value[1];
 1337   2                      C_DATA[9]=g_write_value[2];
 1338   2                      C_DATA[10]=g_write_value[3];
 1339   2                      C_DATA[11]=g_write_value[4];
 1340   2                      C_DATA[12]=g_write_value[5];
 1341   2                      C_DATA[13]=g_write_value[6];
 1342   2                      C_DATA[14]=0x00;
 1343   2                      C_DATA[15]=0x02;
 1344   2                      C_DATA[16]=g_write_value[22]&0x80;
 1345   2                      C_DATA[17]=g_write_value[27];
 1346   2                      usMBCRC16(&C_DATA[2],16);
 1347   2                      C_DATA[18]=ucCRCLo;
 1348   2                      C_DATA[19]=ucCRCHi;
 1349   2                      C_DATA[20]=0X68;
 1350   2                      C_DATA[21]=0X16;
 1351   2                      break;
 1352   2              case 6://IP及端口读取
 1353   2                      C_DATA[6]=0xAB;
 1354   2                      C_DATA[7]=g_write_value[0];
 1355   2                      C_DATA[8]=g_write_value[1];
 1356   2                      C_DATA[9]=g_write_value[2];
 1357   2                      C_DATA[10]=g_write_value[3];
 1358   2                      C_DATA[11]=g_write_value[4];
 1359   2                      C_DATA[12]=g_write_value[5];
 1360   2                      C_DATA[13]=g_write_value[6];
 1361   2                      C_DATA[14]=0x00;
 1362   2                      C_DATA[15]=0x09;
 1363   2                      
 1364   2                      C_DATA[16] =g_write_value[28];
 1365   2                      C_DATA[17]=g_write_value[29];
 1366   2                      C_DATA[18]=g_write_value[30];
 1367   2                      C_DATA[19]=g_write_value[31];
 1368   2                      C_DATA[20]=g_write_value[32];
 1369   2                      C_DATA[21]=g_write_value[33];
 1370   2      
 1371   2                      C_DATA[22]=g_write_value[34];
 1372   2                      
 1373   2                      C_DATA[23]=g_write_value[35];
 1374   2                      C_DATA[24]=g_write_value[36];
 1375   2                      
 1376   2                      usMBCRC16(&C_DATA[2],24);
 1377   2                      C_DATA[25]=ucCRCLo;
 1378   2                      C_DATA[27]=ucCRCHi;
 1379   2                      C_DATA[28]=0x68;
C251 COMPILER V5.04b,  Uart                                                                27/11/18  11:34:35  PAGE 22  

 1380   2                      C_DATA[29]=0x16;
 1381   2                      break;
 1382   2              case 7://冻结数据上传 前10条  1-10
 1383   2                      C_DATA[6]=0xAF;
 1384   2                      C_DATA[7]=g_write_value[0];
 1385   2                      C_DATA[8]=g_write_value[1];
 1386   2                      C_DATA[9]=g_write_value[2];
 1387   2                      C_DATA[10]=g_write_value[3];
 1388   2                      C_DATA[11]=g_write_value[4];
 1389   2                      C_DATA[12]=g_write_value[5];
 1390   2                      C_DATA[13]=g_write_value[6];
 1391   2                      C_DATA[14]=0x00;
 1392   2                      if(g_write_value[20]>10) C_DATA[15]=70;
 1393   2                      else C_DATA[15]=g_write_value[20]*7;
 1394   2                      for(i=0;i<C_DATA[15];i++)//冻结数据转换
 1395   2                      C_DATA[i+16]=meter_data[i];
 1396   2                      C_DATA[15]=C_DATA[15]+1;
 1397   2                      C_DATA[15+C_DATA[15]]=g_write_value[27];
 1398   2                      //校验位
 1399   2                      usMBCRC16(&C_DATA[2],14+C_DATA[15]);
 1400   2                      C_DATA[16+C_DATA[15]]=ucCRCLo;
 1401   2                      C_DATA[17+C_DATA[15]]=ucCRCHi;
 1402   2                      //字尾
 1403   2                      C_DATA[18+C_DATA[15]]=0X68;
 1404   2                      C_DATA[19+C_DATA[15]]=0X16;
 1405   2                      break;
 1406   2              case 8://冻结数据上传 第二个10条 11-20
 1407   2                      C_DATA[6]=0xAF;
 1408   2                      C_DATA[7]=g_write_value[0];
 1409   2                      C_DATA[8]=g_write_value[1];
 1410   2                      C_DATA[9]=g_write_value[2];
 1411   2                      C_DATA[10]=g_write_value[3];
 1412   2                      C_DATA[11]=g_write_value[4];
 1413   2                      C_DATA[12]=g_write_value[5];
 1414   2                      C_DATA[13]=g_write_value[6];
 1415   2                      C_DATA[14]=0x00;
 1416   2                      if(g_write_value[20]>20) C_DATA[15]=70;
 1417   2                      else C_DATA[15]=(g_write_value[20]-10)*7;
 1418   2                      for(i=0;i<C_DATA[15];i++)//冻结数据转换
 1419   2                      C_DATA[16+i]=meter_data[i+70];//i-9+70
 1420   2                      C_DATA[15]=C_DATA[15]+1;
 1421   2                      C_DATA[15+C_DATA[15]]=g_write_value[27];
 1422   2                      //校验位
 1423   2                      usMBCRC16(&C_DATA[2],14+C_DATA[15]);
 1424   2                      C_DATA[16+C_DATA[15]]=ucCRCLo;
 1425   2                      C_DATA[17+C_DATA[15]]=ucCRCHi;
 1426   2                      //字尾
 1427   2                      C_DATA[18+C_DATA[15]]=0X68;
 1428   2                      C_DATA[19+C_DATA[15]]=0X16;
 1429   2                      break;
 1430   2              case 9://冻结数据上传 第三个10条  21-30
 1431   2                      C_DATA[6]=0xAF;
 1432   2                      C_DATA[7]=g_write_value[0];
 1433   2                      C_DATA[8]=g_write_value[1];
 1434   2                      C_DATA[9]=g_write_value[2];
 1435   2                      C_DATA[10]=g_write_value[3];
 1436   2                      C_DATA[11]=g_write_value[4];
 1437   2                      C_DATA[12]=g_write_value[5];
 1438   2                      C_DATA[13]=g_write_value[6];
 1439   2                      C_DATA[14]=0x00;
 1440   2                      if(g_write_value[20]>30) C_DATA[15]=70;
 1441   2                      else C_DATA[15]=(g_write_value[20]-20)*7;
 1442   2                      for(i=0;i<C_DATA[15];i++)//冻结数据转换
 1443   2                      C_DATA[16+i]=meter_data[i+140];//i-9+70
 1444   2                      C_DATA[15]=C_DATA[15]+1;
 1445   2                      C_DATA[15+C_DATA[15]]=g_write_value[27];
C251 COMPILER V5.04b,  Uart                                                                27/11/18  11:34:35  PAGE 23  

 1446   2                      //校验位
 1447   2                      usMBCRC16(&C_DATA[2],14+C_DATA[15]);
 1448   2                      C_DATA[16+C_DATA[15]]=ucCRCLo;
 1449   2                      C_DATA[17+C_DATA[15]]=ucCRCHi;
 1450   2                      //字尾
 1451   2                      C_DATA[18+C_DATA[15]]=0X68;
 1452   2                      C_DATA[19+C_DATA[15]]=0X16;
 1453   2                      break;
 1454   2              case 10://冻结数据上传 第四个10条 31-40
 1455   2                      C_DATA[6]=0xAF;
 1456   2                      C_DATA[7]=g_write_value[0];
 1457   2                      C_DATA[8]=g_write_value[1];
 1458   2                      C_DATA[9]=g_write_value[2];
 1459   2                      C_DATA[10]=g_write_value[3];
 1460   2                      C_DATA[11]=g_write_value[4];
 1461   2                      C_DATA[12]=g_write_value[5];
 1462   2                      C_DATA[13]=g_write_value[6];
 1463   2                      C_DATA[14]=0x00;
 1464   2                      if(g_write_value[20]>40) C_DATA[15]=70;
 1465   2                      else C_DATA[15]=(g_write_value[20]-30)*7;
 1466   2                      for(i=0;i<C_DATA[15];i++)//冻结数据转换
 1467   2                      C_DATA[16+i]=meter_data[i+210];//i-9+70
 1468   2                      C_DATA[15]=C_DATA[15]+1;
 1469   2                      C_DATA[15+C_DATA[15]]=g_write_value[27];
 1470   2                      //校验位
 1471   2                      usMBCRC16(&C_DATA[2],14+C_DATA[15]);
 1472   2                      C_DATA[16+C_DATA[15]]=ucCRCLo;
 1473   2                      C_DATA[17+C_DATA[15]]=ucCRCHi;
 1474   2                      //字尾
 1475   2                      C_DATA[18+C_DATA[15]]=0X68;
 1476   2                      C_DATA[19+C_DATA[15]]=0X16;
 1477   2                      break;
 1478   2              case 11://冻结数据上传 第五个10条 41-48
 1479   2                      C_DATA[6]=0xAF;
 1480   2                      C_DATA[7]=g_write_value[0];
 1481   2                      C_DATA[8]=g_write_value[1];
 1482   2                      C_DATA[9]=g_write_value[2];
 1483   2                      C_DATA[10]=g_write_value[3];
 1484   2                      C_DATA[11]=g_write_value[4];
 1485   2                      C_DATA[12]=g_write_value[5];
 1486   2                      C_DATA[13]=g_write_value[6];
 1487   2                      C_DATA[14]=0x00;
 1488   2                      if(g_write_value[20]>50) C_DATA[15]=70;
 1489   2                      else C_DATA[15]=(g_write_value[20]-40)*7;
 1490   2                      for(i=0;i<C_DATA[15];i++)//冻结数据转换
 1491   2                      C_DATA[16+i]=meter_data[i+280];//i-9+70
 1492   2                      C_DATA[15]=C_DATA[15]+1;
 1493   2                      C_DATA[15+C_DATA[15]]=g_write_value[27];
 1494   2                      //校验位
 1495   2                      usMBCRC16(&C_DATA[2],14+C_DATA[15]);
 1496   2                      C_DATA[16+C_DATA[15]]=ucCRCLo;
 1497   2                      C_DATA[17+C_DATA[15]]=ucCRCHi;
 1498   2                      //字尾
 1499   2                      C_DATA[18+C_DATA[15]]=0X68;
 1500   2                      C_DATA[19+C_DATA[15]]=0X16;
 1501   2                      break;          
 1502   2              }
 1503   1              if(RX0_flag==1)  {TX_Flag=num;j=0;SBUF=C_DATA[j];while(TX_Flag);} 
 1504   1              else NB_NSOST(C_DATA,num,5);
 1505   1      }
 1506          /*******************************************************************************
 1507          * 函  数  名      : RX_Judge
 1508          * 描      述      : 协议处理
 1509          * 输      入      : NULL 
 1510          * 返      回      : NULL
 1511          *******************************************************************************/
C251 COMPILER V5.04b,  Uart                                                                27/11/18  11:34:35  PAGE 24  

 1512          void RX_Judge(void)
 1513          {
 1514   1              uint8_t i;
 1515   1              if(C_DATA[0]==0x1B && C_DATA[1]==0x06 && ((C_DATA[2]==g_write_value[0] && C_DATA[3]==g_write_valu
             -e[1] && C_DATA[4]==g_write_value[2] && C_DATA[5]==g_write_value[3]
 1516   1                       && C_DATA[6]==g_write_value[4] && C_DATA[7]==g_write_value[5] && C_DATA[8]==g_write_value[6])
 1517   1              || (C_DATA[2]==0xAA && C_DATA[3]==0xAA && C_DATA[4]==0xAA && C_DATA[5]==0XAA && C_DATA[6]==0XAA && C_DAT
             -A[7]==0XAA && C_DATA[8]==0XAA))) //地址识别
 1518   1              {
 1519   2                      if(C_DATA[9]==0x41 && C_DATA[10]==0x10 && C_DATA[11]==0x00 && C_DATA[12]==0x00 && C_DATA[13]==0x00)//休
             -眠指令
 1520   2                      {
 1521   3                              usMBCRC16(&C_DATA[2],12);
 1522   3                              if(C_DATA[14]==ucCRCLo && C_DATA[15]==ucCRCHi)
 1523   3                          {   
 1524   4                              Data_deal(0,20);
 1525   4                              CDMA_Wait=100;
 1526   4                              }
 1527   3                      }
 1528   2                      if(C_DATA[9]==0x42 && C_DATA[10]==0x10 && C_DATA[11]==0x00 && C_DATA[12]==0x00 && C_DATA[13]==0x00)//数
             -据上传指令
 1529   2                      {
 1530   3                              usMBCRC16(&C_DATA[2],12);
 1531   3                              if(C_DATA[14]==ucCRCLo && C_DATA[15]==ucCRCHi)
 1532   3                              {
 1533   4                              Data_deal(1,57);
 1534   4                              }
 1535   3                      }
 1536   2                      if(C_DATA[9]==0x4C && C_DATA[10]==0x10 && C_DATA[11]==0x00 && C_DATA[12]==0x00 && C_DATA[13]==0x07)//写
             -表上时间
 1537   2                      {
 1538   3                              usMBCRC16(&C_DATA[2],19);
 1539   3                              if(C_DATA[21]==ucCRCLo && C_DATA[22]==ucCRCHi)
 1540   3                              {
 1541   4                                      g_write_value[13]=C_DATA[14];
 1542   4                                      g_write_value[14]=C_DATA[15];
 1543   4                                      g_write_value[15]=C_DATA[16];
 1544   4                                      g_write_value[16]=C_DATA[17];
 1545   4                                      g_write_value[17]=C_DATA[18];
 1546   4                                      g_write_value[18]=C_DATA[19];
 1547   4                                      g_write_value[19]=C_DATA[20];
 1548   4                                      RTCSet();
 1549   4                                      Read_Flag=0x00;
 1550   4                                      TX_Flag=0xAC;
 1551   4                                      Data_deal(3,21);        
 1552   4                              }
 1553   3                      }
 1554   2                      if(C_DATA[9]==0x43 && C_DATA[10]==0x10 && C_DATA[11]==0x00 && C_DATA[12]==0x00 && C_DATA[13]==0x01)//阀
             -门控制指令
 1555   2                      {
 1556   3                              usMBCRC16(&C_DATA[2],13);
 1557   3                              if(C_DATA[15]==ucCRCLo && C_DATA[16]==ucCRCHi)
 1558   3                              {
 1559   4                                       Read_Flag=0x11;
 1560   4                                       TX_Flag=0xA3;                                                      
 1561   4                                   Data_deal(3,21);
 1562   4                              }
 1563   3                      }
 1564   2                      if(C_DATA[9]==0x44 && C_DATA[10]==0x10 && C_DATA[11]==0x00 && C_DATA[12]==0x00 && C_DATA[13]==0x02)//参
             -数设置
 1565   2                      {
 1566   3                              usMBCRC16(&C_DATA[2],14);
 1567   3                              if(C_DATA[16]==ucCRCLo && C_DATA[17]==ucCRCHi)
 1568   3                              {
 1569   4                                      if(C_DATA[14]==0x00)
 1570   4                                      {
C251 COMPILER V5.04b,  Uart                                                                27/11/18  11:34:35  PAGE 25  

 1571   5                                               if((g_write_value[22]>>7)==0)
 1572   5                                               {
 1573   6                                                       g_write_value[27]=C_DATA[15];
 1574   6                                                       Read_Flag=0x00;
 1575   6                                               }
 1576   5                                               else
 1577   5                                               {
 1578   6                                                      Read_Flag=0x11;
 1579   6                                               }
 1580   5                                      }
 1581   4                                      else if(C_DATA[14]==0x80)
 1582   4                                      {
 1583   5                                                g_write_value[22] |=C_DATA[15];
 1584   5                                                g_write_value[27]=C_DATA[16];
 1585   5                                                Read_Flag=0x00;
 1586   5                                      }
 1587   4                                      else if(C_DATA[14]==0x88)//恢复出厂
 1588   4                                      {
 1589   5                                                g_write_value[22] &=~0x80;
 1590   5                                                g_write_value[7]=0x00;//用水量清零
 1591   5                                                g_write_value[8]=0x00;
 1592   5                                                g_write_value[9]=0x00;
 1593   5                                                Read_Flag=0x22;
 1594   5                                      }
 1595   4                                      //数据存储
 1596   4                                      Write_SegC();
 1597   4                                      TX_Flag=0xA4;
 1598   4                                      Data_deal(3,21);
 1599   4                              }
 1600   3                      }
 1601   2                      if(C_DATA[9]==0x46 && C_DATA[10]==0x10 && C_DATA[11]==0x00 && C_DATA[12]==0x00 && C_DATA[13]==0x00)//读
             -参数 
 1602   2                      {
 1603   3                              usMBCRC16(&C_DATA[2],12);
 1604   3                              if(C_DATA[14]==ucCRCLo && C_DATA[15]==ucCRCHi)
 1605   3                              {
 1606   4                                      Data_deal(4,22);
 1607   4                              }
 1608   3                      }
 1609   2                      if(C_DATA[9]==0x47 && C_DATA[10]==0x10 && C_DATA[11]==0x00 && C_DATA[12]==0x00 && C_DATA[13]==0x00)//读
             -程序版本
 1610   2                      {
 1611   3                              usMBCRC16(&C_DATA[2],12);
 1612   3                              if(C_DATA[14]==ucCRCLo && C_DATA[15]==ucCRCHi)
 1613   3                              {
 1614   4                                       Read_Flag=g_write_value[47];
 1615   4                                       TX_Flag=0xA7;
 1616   4                                   Data_deal(3,21);
 1617   4                              }
 1618   3                      }
 1619   2                      if(C_DATA[9]==0x48 && C_DATA[10]==0x10 && C_DATA[11]==0x00 && C_DATA[12]==0x00 && C_DATA[13]==0x00)//读
             -表地址
 1620   2                      {
 1621   3                              usMBCRC16(&C_DATA[2],12);
 1622   3                              if(C_DATA[14]==ucCRCLo && C_DATA[15]==ucCRCHi)
 1623   3                              {
 1624   4                                       Read_Flag=0x00;
 1625   4                                       TX_Flag=0xA8;
 1626   4                                       Data_deal(3,21);
 1627   4                              }
 1628   3                      }
 1629   2                      if(C_DATA[9]==0x49 && C_DATA[10]==0x10 && C_DATA[11]==0x00 && C_DATA[12]==0x00 && C_DATA[13]==0x07)//写
             -表地址
 1630   2                      {
 1631   3                              usMBCRC16(&C_DATA[2],19);
 1632   3                              if(C_DATA[21]==ucCRCLo && C_DATA[22]==ucCRCHi)
C251 COMPILER V5.04b,  Uart                                                                27/11/18  11:34:35  PAGE 26  

 1633   3                              {
 1634   4                                      g_write_value[0]=C_DATA[14];
 1635   4                                      g_write_value[1]=C_DATA[15];
 1636   4                                      g_write_value[2]=C_DATA[16];
 1637   4                                      g_write_value[3]=C_DATA[17];
 1638   4                                      g_write_value[4]=C_DATA[18];
 1639   4                                      g_write_value[5]=C_DATA[19];
 1640   4                                      g_write_value[6]=C_DATA[20];
 1641   4                                      //数据存储
 1642   4                                      Write_SegC();
 1643   4                                      Read_Flag=0x00;
 1644   4                                      TX_Flag=0xA9;
 1645   4                                      Data_deal(3,21);
 1646   4                              }
 1647   3                      } 
 1648   2                      if(C_DATA[9]==0x4A && C_DATA[10]==0x10 && C_DATA[11]==0x00 && C_DATA[12]==0x00 && C_DATA[13]==0x06)//设
             -置IP&Port
 1649   2                      {
 1650   3                              usMBCRC16(&C_DATA[2],18);
 1651   3                              if(C_DATA[20]==ucCRCLo && C_DATA[21]==ucCRCHi)
 1652   3                              {       //IP信息
 1653   4                                      g_write_value[28]=C_DATA[14];
 1654   4                                      g_write_value[29]=C_DATA[15];
 1655   4                                      g_write_value[30]=C_DATA[16];
 1656   4                                      g_write_value[31]=C_DATA[17];
 1657   4                                      g_write_value[32]=C_DATA[18];
 1658   4                                      g_write_value[33]=C_DATA[19];
 1659   4                                      //数据存储
 1660   4                                      Write_SegC(); 
 1661   4                                      Read_Flag=0x00;
 1662   4                                      TX_Flag=0xAA;
 1663   4                                      Data_deal(3,21);
 1664   4                              }
 1665   3                      }
 1666   2                      if(C_DATA[9]==0x4B && C_DATA[10]==0x10 && C_DATA[11]==0x00 && C_DATA[12]==0x00 && C_DATA[13]==0x00)//读
             -IP及端口
 1667   2                      {
 1668   3                              usMBCRC16(&C_DATA[2],12);
 1669   3                              if(C_DATA[14]==ucCRCLo && C_DATA[15]==ucCRCHi)//CDMA
 1670   3                              {
 1671   4                                       Data_deal(6,37);
 1672   4                              }
 1673   3                      }
 1674   2                      if(C_DATA[9]==0x4D && C_DATA[10]==0x10 && C_DATA[11]==0x00 && C_DATA[12]==0x00 && C_DATA[13]==0x01 && C
             -_DATA[14]==0x11)//故障位清除
 1675   2                      {
 1676   3                              usMBCRC16(&C_DATA[2],13);
 1677   3                              if(C_DATA[15]==ucCRCLo && C_DATA[16]==ucCRCHi)
 1678   3                              {
 1679   4                                      g_write_value[22]&=0x83;//清除故障位
 1680   4                                      g_write_value[23]&=~0xE0;
 1681   4                                      //数据存储
 1682   4                                      Write_SegC();          
 1683   4                                  FDcycflag=1;  
 1684   4                                      flagtype &=~0x80; 
 1685   4                                  flagtype &=~0x0C;       
 1686   4                                  flagtype |= 0x02;      
 1687   4       
 1688   4                                      //清除液晶显示    
 1689   4                                  //LCDRAM13 &=~(BIT1+BIT2+BIT6); 
 1690   4                                      //LCDRAM12 &=~BIT5;  
 1691   4                                      Read_Flag=0x00;
 1692   4                                      TX_Flag=0xAD;
 1693   4                                      Data_deal(3,21);
 1694   4                              }
 1695   3                      }
C251 COMPILER V5.04b,  Uart                                                                27/11/18  11:34:35  PAGE 27  

 1696   2                      if(C_DATA[9]==0x4E && C_DATA[10]==0x10 && C_DATA[11]==0x00 && C_DATA[12]==0x00 && C_DATA[13]==0x03)//设
             -置上报周期和时间
 1697   2                      {
 1698   3                              usMBCRC16(&C_DATA[2],15);
 1699   3                              if(C_DATA[17]==ucCRCLo && C_DATA[18]==ucCRCHi)
 1700   3                              {
 1701   4                                  //上传间隔 hex
 1702   4                                      g_write_value[34]=C_DATA[14];
 1703   4                                      //定时上传时间 时 分  BCD码        
 1704   4                                      g_write_value[35]=C_DATA[15];
 1705   4                                      g_write_value[36]=C_DATA[16];
 1706   4                                      date=mem_date=0;
 1707   4                                      RNG_Time();
 1708   4                                      Write_SegC();
 1709   4                                      Read_Flag=0x00;
 1710   4                                      TX_Flag=0xAE;
 1711   4                                      Data_deal(3,21);
 1712   4                              }
 1713   3                      }
 1714   2                      if(C_DATA[9]==0x4F && C_DATA[10]==0x10 && C_DATA[11]==0x00 && C_DATA[12]==0x00 && C_DATA[13]==0x00)//确
             -认读取冻结数据成功
 1715   2                      {
 1716   3                              usMBCRC16(&C_DATA[2],12);
 1717   3                              if(C_DATA[14]==ucCRCLo && C_DATA[15]==ucCRCHi)
 1718   3                              {
 1719   4                                       g_write_value[46]=2;
 1720   4                                       g_write_value[20]=0; 
 1721   4                                       Write_SegC();
 1722   4                                       Read_Flag=0x22;
 1723   4                                       TX_Flag=0xB0;
 1724   4                                   Data_deal(3,21);
 1725   4                              }
 1726   3                      }
 1727   2                      if(C_DATA[9]==0x45 && C_DATA[10]==0x10 && C_DATA[11]==0x00 && C_DATA[12]==0x00 && C_DATA[13]==0x03)//写
             -表底数
 1728   2                      {
 1729   3                              usMBCRC16(&C_DATA[2],15);
 1730   3                              if(C_DATA[17]==ucCRCLo && C_DATA[18]==ucCRCHi)
 1731   3                              {
 1732   4                                      g_write_value[7]=C_DATA[14];   
 1733   4                                      g_write_value[8]=C_DATA[15];
 1734   4                                      g_write_value[9]=C_DATA[16];
 1735   4                                      Write_SegC();
 1736   4                                      Read_Flag=0x00;
 1737   4                                      TX_Flag=0xA5;
 1738   4                                      Data_deal(3,21);
 1739   4                              }
 1740   3                      }
 1741   2                      for(i=0;i<100;i++)
 1742   2                      {
 1743   3                              C_DATA[i]=0;
 1744   3                      }
 1745   2                      Clear_RX(0);
 1746   2                      y=0;
 1747   2              }
 1748   1              InitData();
 1749   1      }
 1750          /*******************************************************************************
 1751          * 函  数  名      : NB_RX
 1752          * 描      述      : NB模块接收数据处理
 1753          * 输      入      : time 等待返回的时间  
 1754          * 返      回      : 执行结果 1 OK  0 err
 1755          +NNMI:4,AAAA0000
 1756          *******************************************************************************/
 1757          void NB_RX(void)
 1758          {
C251 COMPILER V5.04b,  Uart                                                                27/11/18  11:34:35  PAGE 28  

 1759   1              uint8_t i,n,a,b,temp,num;
 1760   1              for(i=0;i<50;i++)
 1761   1              if(RX0[i]=='A' && RX0[i+1]=='T' && RX0[i+2]=='A' && RX0[i+3]==':')//查询是否有接收到数据
 1762   1              {
 1763   2                      CDMA_time=1;
 1764   2                      while(CDMA_time);
 1765   2                      temp=1;
 1766   2                      break;
 1767   2              }               
 1768   1           if(temp)//接收到数据
 1769   1              {
 1770   2                      temp=0;
 1771   2                      a=Check_Str(',');//找到数据位置
 1772   2                      b=Check_Str(':');
 1773   2                      n=a-b-1;
 1774   2                      if(n==1)
 1775   2                      {
 1776   3                              num=RX0[a-1]-0x30;
 1777   3                      }
 1778   2                      else if(n==2)
 1779   2                      {
 1780   3                              num=RX0[a-1]-0x30;
 1781   3                              num=(RX0[a-2]-0x30)*10+num;
 1782   3                      }
 1783   2                      else if(n==3)
 1784   2                      {
 1785   3                              num=RX0[a-1]-0x30;
 1786   3                              num=(RX0[a-2]-0x30)*10+num;
 1787   3                              num=num+(RX0[a-3]-0x30)*100; //num接收的字节数
 1788   3                      }
 1789   2                      n=a;
 1790   2                      //协议转换
 1791   2                              for(i=0;i<num;i++)
 1792   2                              {
 1793   3                                      a=RX0[n+1+i*2];
 1794   3                                  b=RX0[n+2+i*2];
 1795   3                                      if(a>0x40)
 1796   3                                      {                  
 1797   4                                              if(a==0x41) a=10;
 1798   4                                              if(a==0x42) a=11;
 1799   4                                              if(a==0x43) a=12;
 1800   4                                              if(a==0x44) a=13;
 1801   4                                              if(a==0x45) a=14;
 1802   4                                              if(a==0x46) a=15;
 1803   4                                      }
 1804   3                                      else a=a-0x30;
 1805   3                                      if(b>0x40)
 1806   3                                      {
 1807   4                                              if(b==0x41) b=10;
 1808   4                                              if(b==0x42) b=11;
 1809   4                                              if(b==0x43) b=12;
 1810   4                                              if(b==0x44) b=13;
 1811   4                                              if(b==0x45) b=14;
 1812   4                                              if(b==0x46) b=15;
 1813   4                                      }
 1814   3                                      else b=b-0x30;
 1815   3                                      C_DATA[i]=a*16+b;
 1816   3                              }
 1817   2                              RX_Judge();     //协议判断              
 1818   2              }
 1819   1              else
 1820   1              {
 1821   2                      if(RX0[99]!=0)
 1822   2                      {
 1823   3                               Clear_RX(0);
 1824   3                               y=0;
C251 COMPILER V5.04b,  Uart                                                                27/11/18  11:34:35  PAGE 29  

 1825   3                      }
 1826   2              }
 1827   1      }
 1828          /*******************************************************************************
 1829          * 函  数  名      : NB_Send
 1830          * 描      述      : NB模块上电，并等待工作正常
 1831          * 输      入      : time 等待返回的时间  
 1832          * 返      回      : 执行结果 1 OK  0 err
 1833          *******************************************************************************/
 1834          void NB_Send(void)
 1835          {
 1836   1              Uart_Init();_nop_();_nop_();
 1837   1          z=1;
 1838   1              if(NB_Open(500))//开机成功
 1839   1              {       
 1840   2                      if(NB_IoT())
 1841   2                      {       
 1842   3                              if(NB_CSQ(50))//等待信号稳定
 1843   3                              {        
 1844   4                                      if(NB_CGATT(60))//是否附着成功
 1845   4                                      {       
 1846   5                                              if(NB_CEREG(3))
 1847   5                                              {       
 1848   6                                                      if(NB_NMGS(10))//发送一次数据，激活模组在线
 1849   6                                                      {
 1850   7                                                              CDMA_time=1;
 1851   7                                                              while(CDMA_time);//等待关闭
 1852   7                                                              //IMSI号 15字节 48
 1853   7                                                              NB_CIMI(2);
 1854   7                                                              //SNR 值 2字节 50
 1855   7                                                              NB_NUESTATS(2);
 1856   7                                                              //PCI 值 2字节 51 52
 1857   7                                                              Data_deal(1,57);//发送实时数据
 1858   7                                                              CDMA_time=1;
 1859   7                                                              while(CDMA_time);//等待关闭
 1860   7                                                              Read_Flag=0x22;
 1861   7                                                              TX_Flag=0xB0;
 1862   7                                                      Data_deal(3,21);// 发送标志位 
 1863   7                                                              CDMA_Wait=0;
 1864   7                                                              y=0;
 1865   7                                                              while(CDMA_Wait<40) //在线等待25秒
 1866   7                                                              {                                                               
 1867   8                                                                      NB_RX();//等待数据接收  
 1868   8                                                              }
 1869   7                                                              NB_CFUN(0,15);                                                  
 1870   7                                                      }
 1871   6                                                      else
 1872   6                                                      {
 1873   7                                                              if(NB_CFUN(0,20))//关闭射频
 1874   7                                                              {
 1875   8                                                                      NB_NCSEARFCN(2);
 1876   8                                                                      CDMA_time=1;
 1877   8                                                                      while(CDMA_time);//等待关闭     
 1878   8                                                              }               
 1879   7                                                      }
 1880   6                                                      
 1881   6                                               } 
 1882   5                                      }
 1883   4                                      else
 1884   4                                      {
 1885   5                                              if(NB_CFUN(0,20))//关闭射频
 1886   5                                              {
 1887   6                                                      NB_NCSEARFCN(2);
 1888   6                                                      CDMA_time=1;
 1889   6                                                      while(CDMA_time);//等待关闭     
 1890   6                                              }
C251 COMPILER V5.04b,  Uart                                                                27/11/18  11:34:35  PAGE 30  

 1891   5                                              
 1892   5                                      }
 1893   4                              }
 1894   3                              else
 1895   3                              {
 1896   4                                      if(NB_CFUN(0,20))//关闭射频
 1897   4                                      {
 1898   5                                              NB_NCSEARFCN(2);
 1899   5                                              CDMA_time=1;
 1900   5                                              while(CDMA_time);//等待关闭     
 1901   5                                      }
 1902   4                                      
 1903   4                              }       
 1904   3                      } 
 1905   2              }
 1906   1              NB_Close(1);
 1907   1          z=0; 
 1908   1      }
 1909          /*******************************************************************************
 1910          * 函  数  名      : NB_Send2
 1911          * 描      述      : NB 开机 设置参数
 1912          * 输      入      : time 等待返回的时间  
 1913          * 返      回      : 执行结果 1 OK  0 err
 1914          *******************************************************************************/
 1915          void NB_Send2(void)
 1916          {
 1917   1              Uart_Init();_nop_();_nop_();
 1918   1          z=1;
 1919   1              if(NB_Open(500))//开机成功
 1920   1              {        
 1921   2                      if(NB_CFUN(0,20))//关闭射频
 1922   2                       {                      
 1923   3                              if(NB_IoT_IP(600))//设置IoT IP
 1924   3                              {       
 1925   4                                      NB_IoT_123(500);
 1926   4                                      NB_IoT_124(8);
 1927   4                              }       
 1928   3      
 1929   3                       }              
 1930   2              }
 1931   1              NB_Close(1);
 1932   1          z=0; 
 1933   1      }
 1934          /*******************************************************************************
 1935          * 函  数  名      : Data_UP
 1936          * 描      述      : NB定时上传
 1937          * 输      入      : time 等待返回的时间  
 1938          * 返      回      : 执行结果 1 OK  0 err
 1939          *******************************************************************************/
 1940          void Data_UP(void)
 1941          {
 1942   1              unsigned char send_num=0;
 1943   1              //冻结数据上报
 1944   1              if(g_write_value[20]==0)
 1945   1              {
 1946   2                      Read_Flag=0x00;         
 1947   2              }
 1948   1              else if(g_write_value[20]<11)
 1949   1              {
 1950   2                      send_num=g_write_value[20]*7+21;
 1951   2                      Data_deal(7,send_num);//1-10条 
 1952   2                      Read_Flag=0x11; 
 1953   2              }
 1954   1              else if(g_write_value[20]<21)
 1955   1              {
 1956   2                      send_num=(g_write_value[20]-10)*7+21;
C251 COMPILER V5.04b,  Uart                                                                27/11/18  11:34:35  PAGE 31  

 1957   2                      Data_deal(7,91);//前10条
 1958   2                      CDMA_time=1;
 1959   2                      while(CDMA_time);//等待关闭     
 1960   2                      Data_deal(8,send_num);//11-20条 
 1961   2                      Read_Flag=0x11;
 1962   2              }
 1963   1              else if(g_write_value[20]<31)
 1964   1              {
 1965   2                      send_num=(g_write_value[20]-20)*7+21;
 1966   2                      Data_deal(7,91);//前10条
 1967   2                      CDMA_time=1;
 1968   2                      while(CDMA_time);//等待关闭     
 1969   2                      Data_deal(8,91);//前20条
 1970   2                      CDMA_time=1;
 1971   2                      while(CDMA_time);//等待关闭     
 1972   2                      Data_deal(9,send_num);//21-30条 
 1973   2                      Read_Flag=0x11;                                                 
 1974   2              }
 1975   1              else if(g_write_value[20]<41)
 1976   1              {
 1977   2                      send_num=(g_write_value[20]-30)*7+21;
 1978   2                      Data_deal(7,91);//前10条
 1979   2                      CDMA_time=1;
 1980   2                      while(CDMA_time);//等待关闭     
 1981   2                      Data_deal(8,91);//前20条
 1982   2                      CDMA_time=1;
 1983   2                      while(CDMA_time);//等待关闭     
 1984   2                      Data_deal(9,91);//前30条
 1985   2                      CDMA_time=1;
 1986   2                      while(CDMA_time);//等待关闭     
 1987   2                      Data_deal(10,send_num);//31-40条
 1988   2                      Read_Flag=0x11;                                                         
 1989   2              }
 1990   1              else if(g_write_value[20]<51)
 1991   1              {
 1992   2                      send_num=(g_write_value[20]-40)*7+21;
 1993   2                      Data_deal(7,91);//前10条
 1994   2                      CDMA_time=1;
 1995   2                      while(CDMA_time);//等待关闭     
 1996   2                      Data_deal(8,91);//前20条
 1997   2                      CDMA_time=2;
 1998   2                      while(CDMA_time);//等待关闭     
 1999   2                      Data_deal(9,91);//前30条
 2000   2                      CDMA_time=1;
 2001   2                      while(CDMA_time);//等待关闭     
 2002   2                      Data_deal(10,91);//前40条
 2003   2                      CDMA_time=1;
 2004   2                      while(CDMA_time);//等待关闭     
 2005   2                      Data_deal(11,send_num);//41-50条
 2006   2                      Read_Flag=0x11;                                                         
 2007   2              }
 2008   1              TX_Flag=0xB0;
 2009   1              Data_deal(3,21);        
 2010   1      }
 2011          /*******************************************************************************
 2012          * 函  数  名      : NB_Timing_Send
 2013          * 描      述      : NB定时上传
 2014          * 输      入      : time 等待返回的时间  
 2015          * 返      回      : 执行结果 1 OK  0 err
 2016          *******************************************************************************/
 2017          void NB_Timing_Send(void)
 2018          {
 2019   1              Uart_Init();_nop_();_nop_();
 2020   1          z=1;
 2021   1              if(NB_Open(500))//开机成功
 2022   1              {        
C251 COMPILER V5.04b,  Uart                                                                27/11/18  11:34:35  PAGE 32  

 2023   2                      if(NB_IoT())
 2024   2                      {
 2025   3                              if(NB_CSQ(50))//等待信号稳定
 2026   3                              {        
 2027   4                                      if(NB_CGATT(50))//是否附着成功
 2028   4                                      {       
 2029   5                                              if(NB_CEREG(3))
 2030   5                                              {
 2031   6                                                      if(NB_NMGS(10))//发送一次数据，激活模组上线
 2032   6                                                      {
 2033   7                                                              CDMA_time=1;
 2034   7                                                              while(CDMA_time);//等待关闭     
 2035   7                                                              //IMSI号 15字节 48
 2036   7                                                              NB_CIMI(2);
 2037   7                                                              //SNR 值 2字节 50
 2038   7                                                              NB_NUESTATS(2);
 2039   7                                                              //PCI 值 2字节 51 52
 2040   7                                                              //实时数据上报
 2041   7                                                              Data_deal(1,57);
 2042   7                                                              CDMA_time=1;
 2043   7                                                              while(CDMA_time);
 2044   7                                                              //冻结数据上报
 2045   7                                                              Data_UP();
 2046   7                                                              g_write_value[46]=1;//数据发送标志
 2047   7                                                              //等待数据
 2048   7                                                              CDMA_Wait=0;
 2049   7                                                              y=0;
 2050   7                                                              while(CDMA_Wait<30)
 2051   7                                                              {                                                               
 2052   8                                                                      NB_RX();//等待数据接收  
 2053   8                                                              }
 2054   7                                                              if(g_write_value[46]==1)//上线成功  但是没有接收到平台指令，重新发一次
 2055   7                                                              {
 2056   8                                                                      //IMSI号 15字节 48
 2057   8                                                                      NB_CIMI(2);
 2058   8                                                                      //SNR 值 2字节 50
 2059   8                                                                      NB_NUESTATS(2);
 2060   8                                                                      //PCI 值 2字节 51 52
 2061   8                                                                      //实时数据上报
 2062   8                                                                      Data_deal(1,57);
 2063   8                                                                      CDMA_time=1;
 2064   8                                                                      while(CDMA_time);
 2065   8                                                                      //冻结数据上报
 2066   8                                                                      Data_UP();
 2067   8                                                                      CDMA_Wait=0;
 2068   8                                                                      y=0;
 2069   8                                                                      while(CDMA_Wait<30)
 2070   8                                                                      {                                                               
 2071   9                                                                              NB_RX();//等待数据接收  
 2072   9                                                                      }
 2073   8                                                              }
 2074   7                                                              NB_CFUN(0,15);                                                  
 2075   7                                                      }
 2076   6                                                      else
 2077   6                                                      {
 2078   7                                                              if(NB_CFUN(0,20))//关闭射频
 2079   7                                                              {
 2080   8                                                                      NB_NCSEARFCN(2);
 2081   8                                                                      CDMA_time=1;
 2082   8                                                                      while(CDMA_time);//等待关闭     
 2083   8                                                              }                                                       
 2084   7                                                      }
 2085   6                                                      
 2086   6                                              }       
 2087   5                                      }
 2088   4                                      else
C251 COMPILER V5.04b,  Uart                                                                27/11/18  11:34:35  PAGE 33  

 2089   4                                      {
 2090   5                                              if(NB_CFUN(0,20))//关闭射频
 2091   5                                              {
 2092   6                                                      NB_NCSEARFCN(2);
 2093   6                                                      CDMA_time=1;
 2094   6                                                      while(CDMA_time);//等待关闭     
 2095   6                                              }
 2096   5                                      }
 2097   4                              }
 2098   3                              else
 2099   3                              {
 2100   4                                      if(NB_CFUN(0,20))//关闭射频
 2101   4                                      {
 2102   5                                              NB_NCSEARFCN(2);
 2103   5                                              CDMA_time=1;
 2104   5                                              while(CDMA_time);//等待关闭     
 2105   5                                      }
 2106   4                              }       
 2107   3                      }
 2108   2              }
 2109   1              NB_Close(1);
 2110   1          z=0;
 2111   1      }
 2112          /*******************************************************************************
 2113          * 函  数  名      : RX0_read
 2114          * 描      述      : 下行设置参数读取
 2115          * 输      入      : 无  
 2116          * 返      回      : 无
 2117          *******************************************************************************/
 2118          void RX0_read(void)
 2119          {
 2120   1              uchar i;
 2121   1              RX0_flag=0;z=0;
 2122   1              Uart0_Init();
 2123   1              CDMA_time=1;
 2124   1              while(CDMA_time);//等待接收时间 if(RX1_flag)
 2125   1              if(RX0_flag==1)
 2126   1              {               
 2127   2                      for(i=0;i<40;i++) C_DATA[i]=RX0[i];
 2128   2                      RX_Judge();
 2129   2                      for(i=0;i<40;i++) RX0[i]=0;
 2130   2                      RX0_flag=0;z=0;
 2131   2              }
 2132   1              showIP=0;
 2133   1              NB_Close(1);
 2134   1      }
 2135          //================================================
 2136          //UART中断       串口的奇偶校验均需软件实现
 2137          //================================================
 2138          void INTERRUPT_UART(void) interrupt 4
 2139          {
 2140   1      //------------------------------------------------
 2141   1              if(SCON & U0RI)                                                          //如果是U0接收中断     
 2142   1              {
 2143   2                  SCON &= ~U0RI;                                                       //清除接收中断标志
 2144   2                      RX0[z]=SBUF;
 2145   2                      if(RX0[0]==0x1B)
 2146   2                      {
 2147   3                              z++;
 2148   3                              if(z==(RX0[13]+16)) 
 2149   3                              RX0_flag=1;
 2150   3                              if(z>40) z=0;                   
 2151   3                      }
 2152   2              }
 2153   1      //------------------------------------------------
 2154   1              if(SCON & U0TI)                                                          //如果是U0发送中断
C251 COMPILER V5.04b,  Uart                                                                27/11/18  11:34:35  PAGE 34  

 2155   1              {
 2156   2                      SCON &= ~U0TI;  //清发送完成中断标志
 2157   2                      j++;                                                                     
 2158   2                  if (j < TX_Flag)  SBUF =C_DATA[j];             
 2159   2                  else TX_Flag=0;//表示发送完成 
 2160   2              }
 2161   1      //================================================
 2162   1      //UART1中断      串口的奇偶校验均需软件实现
 2163   1      //================================================
 2164   1              //------------------------------------------------
 2165   1              if(SCON1 & U1RI)                                                                 //如果是U1接收中断
 2166   1              {
 2167   2                      SCON1 &= ~U1RI;
 2168   2                      RX0[y]=SBUF1;
 2169   2                      y++;
 2170   2                      if(y>150) y=0;
 2171   2              }
 2172   1      //------------------------------------------------
 2173   1              if(SCON1 & U1TI)                                                                 //如果是U1发送中断
 2174   1              {       
 2175   2                      SCON1 &= ~U1TI;
 2176   2                      j++;                                                                     
 2177   2                  if (j < TX_Flag)  SBUF1 =TX[j];             
 2178   2                  else TX_Flag=0;//表示发送完成 
 2179   2              }
 2180   1      
 2181   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      9201     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       409          5
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       750     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

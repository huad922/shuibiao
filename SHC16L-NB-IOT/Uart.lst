C251 COMPILER V5.04b,  Uart                                                                25/08/18  14:15:50  PAGE 1   


C251 COMPILER V5.04b, COMPILATION OF MODULE Uart
OBJECT MODULE PLACED IN Uart.obj
COMPILER INVOKED BY: d:\Keil\C251\BIN\C251.EXE SRC\Uart.c XSMALL BROWSE DEBUG PRINT(.\Uart.lst) OBJECT(Uart.obj) 

stmt  level    source

    1          #include "sys.h"
    2          #include "Flash.h"
    3          #include "AD.h"
    4          #include <string.h>
    5          #include "Uart.h"
    6          #include "RTC.h"
    7          #include "HT1621.h"
    8          #include "intrins.h"
    9          #include "Calculate.h"
   10          #include "LCD.h"
   11          
   12          unsigned int j;    //发送计数
   13          uchar y;    //串口0接收计数
   14          
   15          uchar RX0[200];
   16          //uchar RX1[50];
   17          uchar TX[200];
   18          
   19          unsigned int TX_Flag;//发送标志位
   20          uint8_t Read_Flag;
   21          uchar RX1_Flag=0;//串口1接收标志
   22          #define NB_Power_ON      P0 &=~BIT3
   23          #define NB_Power_OFF     P0 |=BIT3
   24          //CRC校验部分
   25          unsigned char ucCRCHi;
   26          unsigned char ucCRCLo;
   27          const unsigned char  aucCRCHi[] = {
   28              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
   29              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
   30              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
   31              0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
   32              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
   33              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
   34              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
   35              0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
   36              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
   37              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
   38              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
   39              0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
   40              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
   41              0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
   42              0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
   43              0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
   44              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
   45              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
   46              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
   47              0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
   48              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
   49              0x00, 0xC1, 0x81, 0x40};
   50          const unsigned char aucCRCLo[] = {
   51              0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7,
   52              0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E,
   53              0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9,
   54              0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,
   55              0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
   56              0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32,
   57              0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D,
   58              0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38,
   59              0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF,
C251 COMPILER V5.04b,  Uart                                                                25/08/18  14:15:50  PAGE 2   

   60              0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
   61              0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1,
   62              0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,
   63              0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB,
   64              0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA,
   65              0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
   66              0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,
   67              0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97,
   68              0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E,
   69              0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89,
   70              0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
   71              0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83,
   72              0x41, 0x81, 0x80, 0x40};
   73          void Uart1_Read_Data(void);
   74          /*******************************************************************************
   75          * 函  数  名      : Set_DCO
   76          * 描      述      : 设置DCO时钟4MHZ 使用外部晶振
   77          * 输      入      : 无.
   78          * 返      回      : 无.
   79          *******************************************************************************/
   80          void Set_DCO(void)
   81          {
   82   1        //时钟初始化-------------------------------------                                                                     
   83   1        CLKC=0x47;
   84   1        //CLKC2 |=BIT5;
   85   1        CLKC1 =(unsigned char)CAL0;                                   //读取主频校准值 4M
   86   1        while(!(CLKC2 & 0X80));                                               //等待主频稳定
   87   1      
   88   1      }
   89          /*******************************************************************************
   90          * 函  数  名      : Uart_Init
   91          * 描      述      : 串口初始化 2400bps 偶校验
   92          * 输      入      : 无.
   93          * 返      回      : 无.
   94          *******************************************************************************/
   95          void Uart_Init(void)
   96          {
   97   1      /*       //UART0初始化
   98   1        P5_DIR  &= ~BIT1;                                                              //p5.1输出TXD
   99   1        P5_DIR  |= BIT0;                                                               //p5.0输入RXD
  100   1        P5_SEL0 &= ~(BIT0 +BIT1);                                              //设置P5.0  P5.1为UART0 RXD TXD 
  101   1        P5_SEL1 |= BIT0 +BIT1;
  102   1        PCON |= U0BRD;                                                                 //波特率翻倍
  103   1        U0_TM =152;//230;//152;                                               //设置波特率 2400bps    
  104   1        U0_TMR &=~ UXTMR;                                                  //启动波特率发生器
  105   1        SCON = 0;//UXSM_3 + UXREN;                                             //设置串口工作方式
  106   1        */
  107   1        //UART1初始化
  108   1        P1_DIR  &= ~BIT7;                                                              //p1.7输出TXD
  109   1        P1_DIR  |= BIT6;                                                               //p1.6输入RXD
  110   1        P1_SEL0 &= ~(BIT6 +BIT7);                                              //设置P1.6  P1.7为UART1 RXD TXD 
  111   1        P1_SEL1 |= BIT6 +BIT7;
  112   1        P1_SEL2 &= ~(BIT6 +BIT7);
  113   1        PCON |= U1BRD;                                                                 //波特率翻倍
  114   1        U1_TM =230;//230;//230;                                                //设置波特率9600
  115   1        U1_TMR |= UXTMR;                                                   //启动波特率发生器
  116   1        SCON1 = UXSM_1 + UXREN;                                                //设置串口工作方式
  117   1        IPH0 |=BIT4;
  118   1        IPL0 |=BIT4;
  119   1        ES = 1;                                                                                //打开串口中断
  120   1      }
  121          /*******************************************************************************
  122          * 函  数  名      : Uart0_Init
  123          * 描      述      : 串口初始化 2400bps 偶校验
  124          * 输      入      : 无.
  125          * 返      回      : 无.
C251 COMPILER V5.04b,  Uart                                                                25/08/18  14:15:50  PAGE 3   

  126          *******************************************************************************/
  127          void Uart0_Init(void)
  128          {
  129   1      //UART0初始化
  130   1        P5_DIR  &= ~BIT1;                                                              //p5.1输出TXD
  131   1        P5_DIR  |= BIT0;                                                               //p5.0输入RXD
  132   1        P5_SEL0 &= ~(BIT0 +BIT1);                                              //设置P5.0  P5.1为UART0 RXD TXD 
  133   1        P5_SEL1 |= BIT0 +BIT1;
  134   1        PCON |= U0BRD;                                                                 //波特率翻倍
  135   1        U0_TM =152;//230;//                                           //设置波特率 2400bps    
  136   1        U0_TMR |=UXTMR;                                                    //启动波特率发生器
  137   1        SCON = UXSM_1 + UXREN;                                                 //设置串口工作方式
  138   1        IPH0 |=BIT4;
  139   1        IPL0 |=BIT4;
  140   1        ES = 1;                                                                                //打开串口中断
  141   1      }
  142          /*******************************************************************************
  143          * 函  数  名      : usMBCRC16
  144          * 描      述      : CRC校验函数
  145          * 输      入      : 无.
  146          * 返      回      : 无.
  147          *******************************************************************************/
  148          void usMBCRC16( unsigned char * pucFrame, unsigned int usLen )
  149          {
  150   1          unsigned int iIndex12;    
  151   1          ucCRCHi = 0xFF;
  152   1          ucCRCLo = 0xFF;
  153   1          while(usLen--)
  154   1          {
  155   2              iIndex12 = ucCRCLo ^ *( pucFrame++ );
  156   2              
  157   2              ucCRCLo = (unsigned char)( ucCRCHi ^ aucCRCHi[iIndex12] );
  158   2              
  159   2              ucCRCHi = aucCRCLo[iIndex12];
  160   2          }
  161   1      }
  162          /*******************************************************************************
  163          * 函  数  名      : Clear_RX
  164          * 描      述      : 清除接收缓存器
  165          * 输      入      : 0，清除RX0；1 清除RX1 
  166          * 返      回      : .
  167          *******************************************************************************/
  168          void Clear_RX(uchar n)
  169          {
  170   1        uchar i;
  171   1        if(!n)
  172   1        for(i=0;i<150;i++)
  173   1        {
  174   2          RX0[i]=0x00;
  175   2        }
  176   1      }
  177          /*******************************************************************************
  178          * 函  数  名      :  
  179          * 描      述      :  
  180          * 输      入      :     
  181          * 返      回      :  
  182          *******************************************************************************/
  183          char *strwu(const char *str1, const char *str2)
  184          {
  185   1          char *cp = (char*)str1;
  186   1          char *s1, *s2;
  187   1       
  188   1          if (!*str2)
  189   1              return((char *)str1);
  190   1       
  191   1          while (*cp)
C251 COMPILER V5.04b,  Uart                                                                25/08/18  14:15:50  PAGE 4   

  192   1          {
  193   2              s1 = cp;
  194   2              s2 = (char *)str2;
  195   2       
  196   2              while (*s1 && *s2 && !(*s1 - *s2))
  197   2                  s1++, s2++;
  198   2       
  199   2              if (!*s2)
  200   2                  return(cp);
  201   2       
  202   2              cp++;
  203   2          }
  204   1          return(NULL);
  205   1      }
  206          /*******************************************************************************
  207          * 函  数  名      : Check_cmd 
  208          * 描      述      : 字检测输入的字符，是否在相关数组中
  209          * 输      入      : 0 检查是否在RX0中；1 检查是否在RX1中   
  210          * 返      回      : 位置信息
  211          *******************************************************************************/
  212          char* Check_cmd(uchar n,char*str)
  213          {
  214   1              char *strx=0;
  215   1              if(n==0)
  216   1              strx=strwu((const char*)RX0,(const char*)str);
  217   1              return (char*)strx;
  218   1      }
  219          /*******************************************************************************
  220          * 函  数  名      : Check_Str 
  221          * 描      述      : 检测相关字符在数组中第一次出现的位置
  222          * 输      入      : 0 检查是否在RX0中；1 检查是否在RX1中   
  223          * 返      回      : 在数组中出现的位置
  224          *******************************************************************************/
  225          uchar Check_Str(char str)
  226          {
  227   1              unsigned char i;
  228   1      
  229   1              for(i=0;i<100;i++)
  230   1              {
  231   2                       if(str==RX0[i])
  232   2                       {
  233   3                              break;
  234   3                       }
  235   2              }
  236   1              return i;
  237   1      }
  238          /*******************************************************************************
  239          * 函  数  名      : Uart0_TX
  240          * 描      述      : 串口0发送触发
  241          * 输      入      : 无
  242          * 返      回      : 无.
  243          *******************************************************************************/
  244          void Uart0_TX(void)
  245          {
  246   1            j = 0;
  247   1                SBUF1=TX[j];
  248   1      }
  249          /*******************************************************************************
  250          * 函  数  名      : NB_Close
  251          * 描      述      : 模块关机，断开NB模块部分电源
  252          * 输      入      : 延迟时间
  253          * 返      回      : NULL
  254          *******************************************************************************/
  255          void NB_Close(uchar time)
  256          {
  257   1              P5_DIR  &= ~BIT1;                                
C251 COMPILER V5.04b,  Uart                                                                25/08/18  14:15:50  PAGE 5   

  258   1          P5_SEL0 &= ~BIT1; 
  259   1          P5_SEL1 &= ~BIT1;
  260   1              P1_DIR  &= ~BIT7;                                                                //p1.7输出TXD
  261   1          P1_DIR  &= ~BIT6;                                                            //p1.6输入RXD
  262   1          P1_SEL0 &= ~(BIT6 +BIT7);                                            //设置P1.6  P1.7为UART1 RXD TXD 
  263   1          P1_SEL1 &= ~(BIT6 +BIT7);
  264   1          P1_SEL2 &= ~(BIT6 +BIT7);
  265   1              P1 &=~(BIT6+BIT7);_nop_();
  266   1              P5 &=~BIT1;_nop_();_nop_(); 
  267   1              P0_DIR &=~BIT0;
  268   1              P0 |=BIT0;_nop_(); //AD监测口
  269   1              _nop_();_nop_();_nop_();_nop_();_nop_();
  270   1              NB_Power_OFF;
  271   1              CDMA_time=time;
  272   1              while(CDMA_time);
  273   1              Show();         
  274   1      }
  275          /*******************************************************************************
  276          * 函  数  名      : NB_Open
  277          * 描      述      : NB模块上电，并等待工作正常
  278          * 输      入      : time 等待返回的时间  
  279          * 返      回      : 执行结果 1 OK  0 err
  280          *******************************************************************************/
  281          uchar NB_Open(uint8 time)
  282          {
  283   1              uchar nb=0;
  284   1              NB_Power_ON; //CDMA_POWER
  285   1              CDMA_time=6;
  286   1              while(CDMA_time); //等待接收时间
  287   1              //while(1);
  288   1              strcpy((char*)TX,"AT\r\n");
  289   1          TX_Flag=4;
  290   1              y=0;Uart0_TX();
  291   1              CDMA_time=2;
  292   1              while(TX_Flag)//等待发送完成
  293   1              {
  294   2                      if(CDMA_time==0)
  295   2                              break;
  296   2              }
  297   1              while(--time)//等待接收时间
  298   1              {
  299   2                      Delay(30);
  300   2                      if(Check_cmd(0,"OK"))
  301   2                      {
  302   3                              nb=0x01;
  303   3                              break;
  304   3                      }
  305   2                      nb=0x00;
  306   2                      if(time==0) break;      
  307   2              }
  308   1              Clear_RX(0);
  309   1              nb=1;
  310   1          return nb;
  311   1      }
  312          /*******************************************************************************
  313          * 函  数  名      : NB_CSQ
  314          * 描      述      : 查询信号值
  315          * 输      入      : time 等待返回的时间  
  316          * 返      回      : 执行结果 1 OK  0 err
  317          *******************************************************************************/
  318          uchar NB_CSQ(uchar time)
  319          {
  320   1              uchar nb=0; 
  321   1              strcpy((char*)TX,"AT+CSQ\r\n");
  322   1          TX_Flag=8;
  323   1              y=0;Uart0_TX();
C251 COMPILER V5.04b,  Uart                                                                25/08/18  14:15:50  PAGE 6   

  324   1              CDMA_time=2;
  325   1              while(TX_Flag)//等待发送完成
  326   1              {
  327   2                      if(CDMA_time==0)
  328   2                              break;
  329   2              }
  330   1              while(--time)//等待接收时间
  331   1              {
  332   2                      CDMA_time=1;
  333   2                      while(CDMA_time); 
  334   2                      if(Check_cmd(0,"OK"))
  335   2                      {
  336   3                              nb=Check_Str(':');
  337   3                              g_write_value[24]=(RX0[nb+1]-0x30)*10+(RX0[nb+2]-0x30);
  338   3                              if(g_write_value[24]<40 && g_write_value[24]>0)//信号值有效
  339   3                              {
  340   4                                      nb=0x01;
  341   4                                      break;//跳出循环        
  342   4                              }
  343   3                              else
  344   3                              {
  345   4                                      Clear_RX(0);
  346   4                                      TX_Flag=8;
  347   4                                      y=0;Uart0_TX();
  348   4                                      CDMA_time=2;
  349   4                                      while(TX_Flag)//等待发送完成
  350   4                                      {
  351   5                                              if(CDMA_time==0)
  352   5                                                      break;
  353   5                                      }
  354   4                              }       
  355   3                      }
  356   2                      nb=0x00;
  357   2                      if(time==0) break;      
  358   2              }
  359   1              //Clear_RX(0);
  360   1          return nb;
  361   1      }
  362          /*******************************************************************************
  363          * 函  数  名      : NB_CGATT
  364          * 描      述      : 查询模块是否附着成功
  365          * 输      入      : time 等待返回的时间  
  366          * 返      回      : 执行结果 1 OK  0 err
  367          *******************************************************************************/
  368          uchar NB_CGATT(uchar time)
  369          {
  370   1              uchar nb=0; 
  371   1              strcpy((char*)TX,"AT+CGATT?\r\n");
  372   1          TX_Flag=11;
  373   1              y=0;Uart0_TX();
  374   1              CDMA_time=2;
  375   1              while(TX_Flag)//等待发送完成
  376   1              {
  377   2                      if(CDMA_time==0)
  378   2                              break;
  379   2              }
  380   1              while(--time)//等待接收时间
  381   1              {
  382   2                      CDMA_time=1;
  383   2                      while(CDMA_time);
  384   2                      if(Check_cmd(0,"OK"))
  385   2                      {
  386   3                              nb=Check_Str(':');
  387   3                              nb=RX0[nb+1]-0x30;
  388   3                              if(nb==1)//附着成功
  389   3                              {
C251 COMPILER V5.04b,  Uart                                                                25/08/18  14:15:50  PAGE 7   

  390   4                                      break;//跳出循环        
  391   4                              }
  392   3                              else
  393   3                              {
  394   4                                      if(Check_cmd(0,"TIND"))
  395   4                                      {
  396   5                                              nb=1;
  397   5                                              break;//跳出循环
  398   5                                      }
  399   4                                      else Clear_RX(0);
  400   4                                      TX_Flag=11;
  401   4                                      y=0;Uart0_TX();
  402   4                                      CDMA_time=2;
  403   4                                      while(TX_Flag)//等待发送完成
  404   4                                      {
  405   5                                              if(CDMA_time==0)
  406   5                                                      break;
  407   5                                      }
  408   4                              }       
  409   3                      }  
  410   2                      nb=0x00;
  411   2                      if(time==0) break;      
  412   2              }
  413   1              Clear_RX(0);
  414   1          return nb;
  415   1      }
  416          /*******************************************************************************
  417          * 函  数  名      : NB_CEREG
  418          * 描      述      : 查询模块网络注册状态
  419          * 输      入      : time 等待返回的时间  
  420          * 返      回      : 执行结果 1 OK  0 err
  421          *******************************************************************************/
  422           uchar NB_CEREG(uchar time)
  423          {
  424   1              uchar nb=0; 
  425   1              strcpy((char*)TX,"AT+CGPADDR\r\n");
  426   1          TX_Flag=12;
  427   1              y=0;Uart0_TX();
  428   1              CDMA_time=2;
  429   1              while(TX_Flag)//等待发送完成
  430   1              {
  431   2                      if(CDMA_time==0)
  432   2                              break;
  433   2              }
  434   1              while(--time)//等待接收时间
  435   1              {
  436   2                      CDMA_time=1;
  437   2                      while(CDMA_time);
  438   2                      if(Check_cmd(0,"OK"))
  439   2                      {
  440   3                              nb=Check_Str(':');
  441   3                              if(RX0[nb+3]+RX0[nb+4])
  442   3                              {
  443   4                                      nb=1;
  444   4                                      break;//跳出循环        
  445   4                              }
  446   3                              else
  447   3                              {
  448   4                                      Clear_RX(0);
  449   4                                      TX_Flag=12;
  450   4                                      y=0;Uart0_TX();
  451   4                                      CDMA_time=2;
  452   4                                      while(TX_Flag)//等待发送完成
  453   4                                      {
  454   5                                              if(CDMA_time==0)
  455   5                                                      break;
C251 COMPILER V5.04b,  Uart                                                                25/08/18  14:15:50  PAGE 8   

  456   5                                      }
  457   4                              }       
  458   3                      }
  459   2                      nb=0x00;
  460   2                      if(time==0) break;      
  461   2              }
  462   1              Clear_RX(0);
  463   1          return nb;
  464   1      }  
  465          /*******************************************************************************
  466          * 函  数  名      : NB_CMEE
  467          * 描      述      : 设置错误返回
  468          * 输      入      : time 等待返回的时间  
  469          * 返      回      : 执行结果 1 OK  0 err
  470          AT+CMEE=1\r\n
  471          *******************************************************************************/
  472          uchar NB_CMEE(uint8 time)
  473          {
  474   1              uchar nb=0;
  475   1              strcpy((char*)TX,"AT+MLWNMI=1\r\n");
  476   1          TX_Flag=13;
  477   1              y=0;Uart0_TX();
  478   1              CDMA_time=2;
  479   1              while(TX_Flag)//等待发送完成
  480   1              {
  481   2                      if(CDMA_time==0)
  482   2                              break;
  483   2              }
  484   1              while(--time)//等待接收时间
  485   1              {
  486   2                      Delay(50);
  487   2                      if(Check_cmd(0,"OK"))
  488   2                      {
  489   3                              nb=0x01;
  490   3                              break;
  491   3                      }
  492   2                      nb=0x00;
  493   2                      if(time==0) break;      
  494   2              }
  495   1              Clear_RX(0);
  496   1          return nb;
  497   1      }
  498          /*******************************************************************************
  499          * 函  数  名      : NB_CELL_RESELECTION
  500          * 描      述      : 设置小区重选
  501          * 输      入      : time 等待返回的时间  
  502          * 返      回      : 执行结果 1 OK  0 err
  503          AT+NCONFIG=CELL_RESELECTION,TRUE
  504          *******************************************************************************/
  505          /*uchar NB_CELL_RESELECTION(uchar time)
  506          {
  507                  uchar nb=0;
  508                  strcpy((char*)TX,"AT+CMEE=1\r\n");
  509              TX_Flag=11;
  510                  y=0;Uart0_TX();
  511                  CDMA_time=2;
  512                  while(TX_Flag)//等待发送完成
  513                  {
  514                          if(CDMA_time==0)
  515                                  break;
  516                  }
  517                  while(--time)//等待接收时间
  518                  {
  519                          Delay(25);
  520                          if(Check_cmd(0,"OK"))
  521                          {
C251 COMPILER V5.04b,  Uart                                                                25/08/18  14:15:50  PAGE 9   

  522                                  nb=0x01;
  523                                  break;
  524                          }
  525                          nb=0x00;
  526                          if(time==0) break;      
  527                  }
  528                  /*Clear_RX(0);
  529                  strcpy((char*)TX,"AT+NEARFCN=0,0\r\n");
  530              TX_Flag=16;
  531                  y=0;Uart0_TX();
  532                  CDMA_time=2;
  533                  while(TX_Flag)//等待发送完成
  534                  {
  535                          if(CDMA_time==0)
  536                                  break;
  537                  }
  538                  while(--time)//等待接收时间
  539                  {
  540                          Delay(50);
  541                          if(Check_cmd(0,"OK"))
  542                          {
  543                                  nb=0x01;
  544                                  break;
  545                          }
  546                          nb=0x00;
  547                          if(time==0) break;      
  548                  }*/
  549          /*      Clear_RX(0);
  550              return nb;
  551          
  552          }*/
  553          /*******************************************************************************
  554          * 函  数  名      : NB_CFUN
  555          * 描      述      : 射频功能操作
  556          * 输      入      : n 0 关闭射频 1  打开射频 time 等待返回的时间  
  557          * 返      回      : 执行结果 1 OK  0 err
  558          *******************************************************************************/
  559          uchar NB_CFUN(uchar n,uchar time)
  560          {
  561   1              uchar nb=0;
  562   1              strcpy((char*)TX,"AT+CFUN=");
  563   1              if(n) TX[8]=0x31;
  564   1              else  TX[8]=0x30;
  565   1              TX[9]=0x0D;
  566   1              TX[10]=0x0A;
  567   1          TX_Flag=11;
  568   1              y=0;Uart0_TX();
  569   1              CDMA_time=2;
  570   1              while(TX_Flag)//等待发送完成
  571   1              {
  572   2                      if(CDMA_time==0)
  573   2                              break;
  574   2              }
  575   1              CDMA_time=time;
  576   1              while(CDMA_time)//等待接收时间
  577   1              {
  578   2                      Delay(4000);
  579   2                      if(Check_cmd(0,"OK"))
  580   2                      {
  581   3                              nb=0x01;
  582   3                              break;
  583   3                      }
  584   2                      if(Check_cmd(0,"ERR"))
  585   2                      {
  586   3                              Clear_RX(0);
  587   3                              TX_Flag=11;
C251 COMPILER V5.04b,  Uart                                                                25/08/18  14:15:50  PAGE 10  

  588   3                              y=0;Uart0_TX();
  589   3                              while(TX_Flag)//等待发送完成
  590   3                              {
  591   4                                      if(CDMA_time==0)
  592   4                                              break;
  593   4                              }                       
  594   3                      }
  595   2                      nb=0x00;
  596   2                      if(CDMA_time==0) break; 
  597   2              }
  598   1              Clear_RX(0);
  599   1          return nb;
  600   1      }
  601          /*******************************************************************************
  602          * 函  数  名      : NB_IoT_IP
  603          * 描      述      : IOT平台地址
  604          * 输      入      : time 等待返回的时间  
  605          * 返      回      : 执行结果 1 OK  0 err
  606          AT+NCDP=117.60.157.137,5683
  607          AT+NCDP=180.101.147.115,5683
  608          *******************************************************************************/
  609          uchar NB_IoT_IP(uint8 time)
  610          {
  611   1              uchar nb=0;
  612   1              strcpy((char*)TX,"AT+NCDP=117.60.157.137,5683\r\n");
  613   1          TX_Flag=29;
  614   1              y=0;Uart0_TX();
  615   1              CDMA_time=2;
  616   1              while(TX_Flag)//等待发送完成
  617   1              {
  618   2                      if(CDMA_time==0)
  619   2                              break;
  620   2              }
  621   1              while(--time)//等待接收时间
  622   1              {
  623   2                      Delay(50);
  624   2                      if(Check_cmd(0,"OK"))
  625   2                      {
  626   3                              nb=0x01;
  627   3                              break;
  628   3                      }
  629   2                      nb=0x00;
  630   2                      if(time==0) break;              
  631   2              }
  632   1              Clear_RX(0);
  633   1          return nb;
  634   1      }
  635          /*******************************************************************************
  636          * 函  数  名      : NB_IoT_123
  637          * 描      述      : 读取IOT平台地址
  638          * 输      入      : time 等待返回的时间  
  639          * 返      回      : 执行结果 1 OK  0 err
  640          AT+NCDP=117.60.157.137,5683
  641          AT+NCDP=180.101.147.115,5683
  642          *******************************************************************************/
  643          uchar NB_IoT_123(uint8 time)
  644          {
  645   1              uchar nb=0;
  646   1              strcpy((char*)TX,"AT+NCDP?\r\n");
  647   1          TX_Flag=10;
  648   1              y=0;Uart0_TX();
  649   1              CDMA_time=2;
  650   1              while(TX_Flag)//等待发送完成
  651   1              {
  652   2                      if(CDMA_time==0)
  653   2                              break;
C251 COMPILER V5.04b,  Uart                                                                25/08/18  14:15:50  PAGE 11  

  654   2              }
  655   1              while(--time)//等待接收时间
  656   1              {
  657   2                      Delay(50);
  658   2                      if(Check_cmd(0,"OK"))
  659   2                      {
  660   3                              nb=0x01;
  661   3                              break;
  662   3                      }
  663   2                      nb=0x00;
  664   2                      if(time==0) break;              
  665   2              }
  666   1              Clear_RX(0);
  667   1          return nb;
  668   1      }
  669          /*******************************************************************************
  670          * 函  数  名      : NB_IoT_124
  671          * 描      述      : AT 指令重启模组
  672          * 输      入      : time 等待返回的时间  
  673          * 返      回      : 执行结果 1 OK  0 err
  674          AT+NCDP=117.60.157.137,5683
  675          AT+NCDP=180.101.147.115,5683
  676          *******************************************************************************/
  677          uchar NB_IoT_124(uchar time)
  678          {
  679   1              uchar nb=0;
  680   1              strcpy((char*)TX,"AT+NRB\r\n");
  681   1          TX_Flag=8;
  682   1              y=0;Uart0_TX();
  683   1              CDMA_time=2;
  684   1              while(TX_Flag)//等待发送完成
  685   1              {
  686   2                      if(CDMA_time==0)
  687   2                              break;
  688   2              }
  689   1              while(--time)//等待接收时间
  690   1              {
  691   2                      CDMA_time=1;
  692   2                      while(CDMA_time);
  693   2                      if(Check_cmd(0,"OK"))
  694   2                      {
  695   3                              nb=0x01;
  696   3                              break;
  697   3                      }
  698   2                      nb=0x00;
  699   2                      if(time==0) break;              
  700   2              }
  701   1              Clear_RX(0);
  702   1          return nb;
  703   1      }
  704          /*******************************************************************************
  705          * 函  数  名      : NB_CGA 
  706          * 描      述      : 进行终端入网
  707          * 输      入      : time 等待返回的时间  
  708          * 返      回      : 执行结果 1 OK  0 err
  709          *******************************************************************************/
  710          /*uchar NB_CGA(uchar time)
  711          {
  712                  uchar nb=0;
  713                  strcpy((char*)TX,"AT+CGATT=1\r\n");
  714              TX_Flag=12;
  715                  y=0;Uart0_TX();
  716                  CDMA_time=2;
  717                  while(TX_Flag)//等待发送完成
  718                  {
  719                          if(CDMA_time==0)
C251 COMPILER V5.04b,  Uart                                                                25/08/18  14:15:50  PAGE 12  

  720                                  break;
  721                  }
  722                  CDMA_time=time;
  723                  while(CDMA_time)//等待接收时间
  724                  {
  725                          CDMA_Wait=0;
  726                          while(CDMA_Wait<1);
  727                          if(Check_cmd(0,"OK"))
  728                          {
  729                                  nb=0x01;
  730                                  break;
  731                          }
  732                      if(Check_cmd(0,"ERR"))
  733                          {
  734                                  Clear_RX(0);
  735                                  TX_Flag=12;
  736                                  y=0;Uart0_TX();
  737                                  while(TX_Flag)//等待发送完成
  738                                  {
  739                                          if(CDMA_time==0)
  740                                                  break;
  741                                  }                       
  742                          }
  743                          nb=0x00;
  744                          if(CDMA_time==0) break;         
  745                  }
  746                  Clear_RX(0);
  747              return nb;
  748          }*/
  749          /*******************************************************************************
  750          * 函  数  名      : NB_NUESTATS 
  751          * 描      述      : 查询模块状态
  752          * 输      入      : time 等待返回的时间  
  753          * 返      回      : 1 一致  0 不一致
  754          +NCDP:117.60.157.137,5683
  755          
  756          *******************************************************************************/
  757          uchar NB_NUESTATS(uint8 time)
  758           {
  759   1              uchar nb=0,i,a;
  760   1              strcpy((char*)TX,"AT+NUESTATS\r\n");
  761   1          TX_Flag=13;
  762   1              y=0;Uart0_TX();
  763   1              CDMA_time=2;
  764   1              while(TX_Flag)//等待发送完成
  765   1              {
  766   2                      if(CDMA_time==0)
  767   2                              break;
  768   2              }
  769   1              CDMA_time=time;
  770   1              while(CDMA_time)//等待接收时间
  771   1              {
  772   2                      Delay(50);
  773   2                      if(Check_cmd(0,"RSRQ"))
  774   2                      {
  775   3                              //SNR
  776   3                              for(i=0;i<200;i++)
  777   3                              {
  778   4                                      if(RX0[i]=='R' && RX0[i+1]==':')
  779   4                                      {
  780   5                                              break;
  781   5                                      }
  782   4                              }
  783   3                              a=i+2;
  784   3                              if(RX0[a]>0x39 || RX0[a]<0x30)//信号值异常
  785   3                              {
C251 COMPILER V5.04b,  Uart                                                                25/08/18  14:15:50  PAGE 13  

  786   4                                      C_DATA[49]=0XFF;
  787   4                                      C_DATA[50]=0XFF;        
  788   4                              }
  789   3                              else//信号值不为负
  790   3                              {
  791   4                                      for(i=0;i<10;i++)
  792   4                                      {
  793   5                                              if(RX0[i+a]==0x0D) break;//查询结束符
  794   5                                      }
  795   4                                      if(i==1)
  796   4                                      {
  797   5                                              C_DATA[49]=0x00;
  798   5                                              C_DATA[50]=RX0[a]-0x30;
  799   5                                      }
  800   4                                      else if(i==2)
  801   4                                      {
  802   5                                              C_DATA[49]=0x00;
  803   5                                              C_DATA[50]=(RX0[a]-0x30)*16+RX0[a+1]-0x30;
  804   5                                      }
  805   4                                      else if(i==3)
  806   4                                      {
  807   5                                              C_DATA[49]=RX0[a]-0x30;
  808   5                                              C_DATA[50]=(RX0[a+1]-0x30)*16+RX0[a+2]-0x30;    
  809   5                                      }                                       
  810   4                              }
  811   3                              //PCI
  812   3                              for(i=0;i<200;i++)
  813   3                              {
  814   4                                      if(RX0[i]=='P' && RX0[i+1]=='C' && RX0[i+2]=='I' && RX0[i+3]==':' )
  815   4                                      {
  816   5                                              break;
  817   5                                      }
  818   4                              }
  819   3                              a=i+4;
  820   3                              for(i=0;i<10;i++)
  821   3                              {
  822   4                                      if(RX0[i+a]==0x0D) break;//查询结束符
  823   4                              }
  824   3                              if(i==1)
  825   3                              {
  826   4                                      g_write_value[51]=0x00;
  827   4                                      g_write_value[52]=RX0[a]-0x30;
  828   4                              }
  829   3                              else if(i==2)
  830   3                              {
  831   4                                      C_DATA[51]=0x00;
  832   4                                      C_DATA[52]=(RX0[a]-0x30)*16+RX0[a+1]-0x30;
  833   4                              }
  834   3                              else if(i==3)
  835   3                              {
  836   4                                      C_DATA[51]=RX0[a]-0x30;
  837   4                                      C_DATA[52]=(RX0[a+1]-0x30)*16+RX0[a+2]-0x30;    
  838   4                              }                                       
  839   3                              nb=0x01;
  840   3                              break;
  841   3                      }
  842   2                      nb=0x00;
  843   2                      if(CDMA_time==0) break;         
  844   2              }
  845   1              Clear_RX(0);
  846   1          return nb;
  847   1      }
  848          /*******************************************************************************
  849          * 函  数  名      : NB_CIMI 
  850          * 描      述      : 查询模块状态
  851          * 输      入      : time 等待返回的时间  
C251 COMPILER V5.04b,  Uart                                                                25/08/18  14:15:50  PAGE 14  

  852          * 返      回      : 1 一致  0 不一致
  853          +NCDP:117.60.157.137,5683
  854          
  855          *******************************************************************************/
  856          uchar NB_CIMI(uchar time)
  857           {
  858   1              uchar nb=0,i,a;
  859   1              strcpy((char*)TX,"AT+CIMI\r\n");
  860   1          TX_Flag=9;
  861   1              y=0;Uart0_TX();
  862   1              CDMA_time=2;
  863   1              while(TX_Flag)//等待发送完成
  864   1              {
  865   2                      if(CDMA_time==0)
  866   2                              break;
  867   2              }
  868   1              CDMA_time=time;
  869   1              while(CDMA_time)//等待接收时间
  870   1              {
  871   2                      Delay(50);
  872   2                      if(Check_cmd(0,"OK"))
  873   2                      {
  874   3                              for(i=0;i<200;i++)
  875   3                              {
  876   4                                      if(RX0[i]==0x4F && RX0[i+1]==0x4B)
  877   4                                      {
  878   5                                              break;
  879   5                                      }
  880   4                              }
  881   3                              a=i-19;
  882   3                              for(i=0;i<15;i++)
  883   3                              {
  884   4                                      C_DATA[34+i]=RX0[a+i];
  885   4                              }                                       
  886   3                              nb=0x01;
  887   3                              break;
  888   3                      }
  889   2                      nb=0x00;
  890   2                      if(CDMA_time==0) break;         
  891   2              }
  892   1              Clear_RX(0);
  893   1          return nb;
  894   1      }
  895          /*******************************************************************************
  896          * 函  数  名      : NB_NMGS 
  897          * 描      述      : 确认终端可以进行数据发送
  898          * 输      入      : time 等待返回的时间  
  899          * 返      回      : 执行结果 1 OK  0 err
  900          *******************************************************************************/
  901          uchar NB_NMGS(uchar time)
  902          {
  903   1              uchar nb=0;
  904   1              //发送一次数据 验证是否连接平台成功
  905   1              strcpy((char*)TX,"AT+MLWULDATA=4,AAAA0000\r\n");
  906   1          TX_Flag=25;
  907   1              y=0;Uart0_TX();
  908   1              CDMA_time=2;
  909   1              while(TX_Flag)//等待发送完成
  910   1              {
  911   2                      if(CDMA_time==0)
  912   2                              break;
  913   2              }
  914   1              //CDMA_time=time;
  915   1              while(--time)//等待接收时间
  916   1              {
  917   2                      CDMA_time=1;
C251 COMPILER V5.04b,  Uart                                                                25/08/18  14:15:50  PAGE 15  

  918   2                      while(CDMA_time);
  919   2                      if(Check_cmd(0,"OK"))
  920   2                      {
  921   3                              nb=0x01;
  922   3                              break;
  923   3                      }
  924   2                      if(Check_cmd(0,"ERR"))
  925   2                      {
  926   3                              Clear_RX(0);
  927   3                          TX_Flag=25;
  928   3                              y=0;Uart0_TX();
  929   3                              while(TX_Flag)//等待发送完成
  930   3                              {
  931   4                                      if(CDMA_time==0)
  932   4                                              break;
  933   4                              }                       
  934   3                      }
  935   2                      nb=0x00;
  936   2                      if(time==0) break;              
  937   2              }
  938   1              Clear_RX(0);
  939   1              if(nb)//查询是否处于发送状态
  940   1              {
  941   2                      strcpy((char*)TX,"AT+MLWMSTATUS?\r\n");
  942   2                  TX_Flag=16;
  943   2                      y=0;Uart0_TX();
  944   2                      CDMA_time=2;
  945   2                      while(TX_Flag)//等待发送完成
  946   2                      {
  947   3                              if(CDMA_time==0)
  948   3                                      break;
  949   3                      }
  950   2                      time=500;
  951   2                      while(--time)//等待接收时间
  952   2                      {
  953   3                              Delay(15);
  954   3                              if(Check_cmd(0,"ENABLED"))
  955   3                              {
  956   4                                      nb=0x01;
  957   4                                      break;
  958   4                              }
  959   3                              nb=0x00;
  960   3                              if(time==0) break;              
  961   3                      }       
  962   2              }
  963   1               Clear_RX(0);
  964   1          return nb;
  965   1      }
  966          /*******************************************************************************
  967          * 函  数  名      : NB_eDRX 
  968          * 描      述      : 关闭eDRX
  969          * 输      入      : time 等待返回的时间  
  970          * 返      回      : 执行结果 1 OK  0 err
  971          *******************************************************************************/
  972          /*uchar NB_eDRX(uchar time)
  973          {
  974                  uchar nb=0;
  975                  strcpy((char*)TX,"AT+CEDRXS=0,5,");
  976                  TX[14]=0x22;
  977                  TX[15]=0x30;
  978                  TX[16]=0x31;
  979                  TX[17]=0x30;
  980                  TX[18]=0x31;
  981                  TX[19]=0x22;
  982                  TX[20]=0x0D;
  983                  TX[21]=0x0A;
C251 COMPILER V5.04b,  Uart                                                                25/08/18  14:15:50  PAGE 16  

  984              TX_Flag=22;
  985                  y=0;Uart0_TX();
  986                  CDMA_time=2;
  987                  while(TX_Flag)//等待发送完成
  988                  {
  989                          if(CDMA_time==0)
  990                                  break;
  991                  }
  992                  CDMA_time=time;
  993                  while(CDMA_time)//等待接收时间
  994                  {
  995                          Delay(50);
  996                          if(Check_cmd(0,"OK"))
  997                          {
  998                                  nb=0x01;
  999                                  break;
 1000                          }
 1001                          nb=0x00;
 1002                          if(CDMA_time==0) break;         
 1003                  }
 1004                  Clear_RX(0);
 1005              return nb;
 1006          }*/
 1007          /*******************************************************************************
 1008          * 函  数  名      : NB_PSM 
 1009          * 描      述      : 关闭PSM
 1010          * 输      入      : time 等待返回的时间  
 1011          * 返      回      : 执行结果 1 OK  0 err
 1012          *******************************************************************************/
 1013          /*uchar NB_PSM(uchar time)
 1014          {
 1015                  uchar nb=0;
 1016                  strcpy((char*)TX,"AT+CPSMS=0\r\n");
 1017              TX_Flag=12;
 1018                  y=0;Uart0_TX();
 1019                  CDMA_time=2;
 1020                  while(TX_Flag)//等待发送完成
 1021                  {
 1022                          if(CDMA_time==0)
 1023                                  break;
 1024                  }
 1025                  while(--time)//等待接收时间
 1026                  {
 1027                          Delay(50);
 1028                          if(Check_cmd(0,"OK"))
 1029                          {
 1030                                  nb=0x01;
 1031                                  break;
 1032                          }
 1033                          nb=0x00;
 1034                          if(time==0) break;              
 1035                  }
 1036                  Clear_RX(0);
 1037              return nb;
 1038          }*/
 1039          /*******************************************************************************
 1040          * 函  数  名      : NB_NCSEARFCN
 1041          * 描      述      : 清频
 1042          * 输      入      : time 等待返回的时间 单位秒  
 1043          * 返      回      : 状态值：1 ok  0 err
 1044          *******************************************************************************/
 1045          uchar NB_NCSEARFCN(uchar time)
 1046           {
 1047   1              uchar nb=0;
 1048   1              strcpy((char*)TX,"AT+NCSEARFCN\r\n");
 1049   1          TX_Flag=14;
C251 COMPILER V5.04b,  Uart                                                                25/08/18  14:15:50  PAGE 17  

 1050   1              y=0;Uart0_TX();
 1051   1              CDMA_time=2;
 1052   1              while(TX_Flag)//等待发送完成
 1053   1              {
 1054   2                      if(CDMA_time==0)
 1055   2                              break;
 1056   2              }
 1057   1              CDMA_time=time;
 1058   1              while(CDMA_time)//等待接收时间
 1059   1              {
 1060   2                      Delay(50);
 1061   2                      if(Check_cmd(0,"OK"))
 1062   2                      {       
 1063   3                              nb=0x01;
 1064   3                              break;
 1065   3                      }
 1066   2                      nb=0x00;
 1067   2                      if(CDMA_time==0) break; 
 1068   2              }
 1069   1              Clear_RX(0);
 1070   1          return nb;
 1071   1      }
 1072          /*******************************************************************************
 1073          * 函  数  名      : NB_IoT
 1074          * 描      述      : 设置平台连接参数
 1075          * 输      入      : qwe 需要发送的数据起始地址；n 发送的数据位数；time 等待返回的时间 单位秒  
 1076          * 返      回      : 状态值：1 ok  0 err
 1077          *******************************************************************************/
 1078          uchar NB_IoT(void)
 1079          {
 1080   1              uchar nb=0;
 1081   1              NB_IoT_123(500);
 1082   1              CDMA_time=1;
 1083   1              while(CDMA_time);//等待接收时间
 1084   1              NB_CMEE(500);
 1085   1              CDMA_time=1;
 1086   1              while(CDMA_time);//等待接收时间
 1087   1              nb=1;
 1088   1              return nb;
 1089   1      }
 1090          /*******************************************************************************
 1091          * 函  数  名      : NB_NSOST
 1092          * 描      述      : 发送数据
 1093          * 输      入      : qwe 需要发送的数据起始地址；n 发送的数据位数；time 等待返回的时间 单位秒  
 1094          * 返      回      : 状态值：1 ok  0 err
 1095          AT+NMGS=5,00012E1F63
 1096          *******************************************************************************/
 1097          uchar NB_NSOST(uchar* qwe,unsigned short n,uchar time)
 1098          {
 1099   1              uchar nb=0,s,a,b;//c,d,e,f;
 1100   1              //NB_NSOCR(1);
 1101   1              strcpy((char*)TX,"AT+MLWULDATA=");_nop_();
 1102   1              if(n>99)
 1103   1              {
 1104   2                      TX[13]=n/100+0x30;
 1105   2                      TX[14]=(n%100)/10+0x30;
 1106   2                      TX[15]=n%10+0x30;
 1107   2                      nb=16;  
 1108   2              }
 1109   1              else if(n>9)
 1110   1              {
 1111   2                      TX[13]=n/10+0x30;
 1112   2                      TX[14]=n%10+0x30;
 1113   2                      nb=15;
 1114   2              }
 1115   1              else 
C251 COMPILER V5.04b,  Uart                                                                25/08/18  14:15:50  PAGE 18  

 1116   1              {
 1117   2                      TX[13]=n+0x30;
 1118   2                      nb=14;
 1119   2              }
 1120   1              TX[nb]=0x2C;
 1121   1              //协议加载，待发送
 1122   1              for(s=0;s<n;s++)
 1123   1              {
 1124   2                  a=qwe[s]/16;
 1125   2                      b=qwe[s]%16;
 1126   2                      if(a>9)
 1127   2                      {
 1128   3                              if(a==10) a=0x41;
 1129   3                              if(a==11) a=0x42;
 1130   3                              if(a==12) a=0x43;
 1131   3                              if(a==13) a=0x44;
 1132   3                              if(a==14) a=0x45;
 1133   3                              if(a==15) a=0x46;
 1134   3                      }
 1135   2                      else a=a+0x30;
 1136   2                      if(b>9)
 1137   2                      {
 1138   3                      if(b==10) b=0x41;
 1139   3                      if(b==11) b=0x42;
 1140   3                      if(b==12) b=0x43;
 1141   3                      if(b==13) b=0x44;
 1142   3                      if(b==14) b=0x45;
 1143   3                      if(b==15) b=0x46;
 1144   3                      }
 1145   2                      else b=b+0x30;
 1146   2                      TX[nb+1+2*s]=a;
 1147   2                      TX[nb+2+2*s]=b;
 1148   2              }
 1149   1              TX[nb+1+2*n]=0x0D;
 1150   1              TX[nb+2+2*n]=0x0A;
 1151   1              TX_Flag=nb+3+2*n;
 1152   1              Uart0_TX();
 1153   1              CDMA_time=2;
 1154   1              while(TX_Flag)//等待发送完成
 1155   1              {
 1156   2                      if(CDMA_time==0)
 1157   2                              break;
 1158   2              }
 1159   1              y=0;
 1160   1              CDMA_time=time;
 1161   1              while(--time)//等待接收时间
 1162   1              {
 1163   2                      CDMA_time=1;
 1164   2                      while(CDMA_time);
 1165   2                      if(Check_cmd(0,"OK")) 
 1166   2                      {
 1167   3                          nb=0x01;
 1168   3                          break;
 1169   3                      }
 1170   2                      else if(Check_cmd(0,"ERR"))
 1171   2                      {
 1172   3                              TX_Flag=nb+3+2*n;
 1173   3                              y=0;Uart0_TX();
 1174   3                              while(TX_Flag);//等待发送完成                   
 1175   3                      }
 1176   2                      else nb=0x00;
 1177   2                      if(CDMA_time==0) break; 
 1178   2              }
 1179   1              Clear_RX(0);
 1180   1          return nb;          
 1181   1      }
C251 COMPILER V5.04b,  Uart                                                                25/08/18  14:15:50  PAGE 19  

 1182          /*******************************************************************************
 1183          * 函  数  名      : Data_deal
 1184          * 描      述      : NB模块上电，并等待工作正常
 1185          * 输      入      : cs 协议编码，num 发送数据数量  
 1186          * 返      回      : 执行结果 1 OK  0 err
 1187          *******************************************************************************/
 1188          void Data_deal(uint8_t cs,unsigned short num)
 1189          {
 1190   1          unsigned short i;
 1191   1              C_DATA[0]=0x1B;
 1192   1              C_DATA[1]=0x06;
 1193   1              C_DATA[2]=0x66;//g_write_value[0];
 1194   1              C_DATA[3]=0x66;//g_write_value[1];
 1195   1          C_DATA[4]=0x66;//g_write_value[2];
 1196   1              C_DATA[5]=0x66;//g_write_value[3];
 1197   1              switch(cs)
 1198   1              {
 1199   2              case 0://心跳包
 1200   2                      C_DATA[6]=0xA1;
 1201   2                      C_DATA[7]=g_write_value[0];
 1202   2                      C_DATA[8]=g_write_value[1];
 1203   2                      C_DATA[9]=g_write_value[2];
 1204   2                      C_DATA[10]=g_write_value[3];
 1205   2                      C_DATA[11]=g_write_value[4];
 1206   2                      C_DATA[12]=g_write_value[5];
 1207   2                      C_DATA[13]=g_write_value[6];
 1208   2                      C_DATA[14]=0x00;
 1209   2                      C_DATA[15]=0x00;
 1210   2                      usMBCRC16(&C_DATA[2],14);
 1211   2                      C_DATA[16]=ucCRCLo;
 1212   2                      C_DATA[17]=ucCRCHi;
 1213   2                      C_DATA[18]=0x68;
 1214   2                      C_DATA[19]=0x16;
 1215   2                      break;
 1216   2              case 1://数据上传
 1217   2                      //电压采集
 1218   2                      ADC_Read();
 1219   2                      //信号强度采集
 1220   2                      g_write_value[23] =(g_write_value[23]&0xE0)+(g_write_value[24]&0x1F);
 1221   2                      C_DATA[6]=0xA2;
 1222   2                      C_DATA[7]=g_write_value[0];
 1223   2                      C_DATA[8]=g_write_value[1];
 1224   2                      C_DATA[9]=g_write_value[2];
 1225   2                      C_DATA[10]=g_write_value[3];
 1226   2                      C_DATA[11]=g_write_value[4];
 1227   2                      C_DATA[12]=g_write_value[5];
 1228   2                      C_DATA[13]=g_write_value[6];
 1229   2                      C_DATA[14]=0x00;
 1230   2                      C_DATA[15]=0x25;
 1231   2                      //用户总用水量
 1232   2                      C_DATA[16]=g_write_value[7];
 1233   2                      C_DATA[17]=g_write_value[8];
 1234   2                      C_DATA[18]=g_write_value[9];
 1235   2                      //表上时间
 1236   2                      C_DATA[19]=g_write_value[13];
 1237   2                      C_DATA[20]=g_write_value[14];
 1238   2                      C_DATA[21]=g_write_value[15];
 1239   2                      C_DATA[22]=g_write_value[16];
 1240   2                      C_DATA[23]=g_write_value[17];
 1241   2                      C_DATA[24]=g_write_value[18];
 1242   2                      C_DATA[25]=g_write_value[19];
 1243   2                      //上传间隔
 1244   2                      C_DATA[26]=g_write_value[34];
 1245   2                      //上传时间
 1246   2                      C_DATA[27]=g_write_value[35];//g_write_value[120];
 1247   2                      C_DATA[28]=g_write_value[36];//g_write_value[121];
C251 COMPILER V5.04b,  Uart                                                                25/08/18  14:15:50  PAGE 20  

 1248   2                      //脉冲当量
 1249   2                      C_DATA[29]=g_write_value[27];
 1250   2                      //电池电压
 1251   2                      C_DATA[30]=g_write_value[38];
 1252   2                      //表状态
 1253   2                      C_DATA[31]=g_write_value[22];
 1254   2                      C_DATA[32]=g_write_value[23];
 1255   2                      //已冻结数据条数
 1256   2                      C_DATA[33]=g_write_value[20];
 1257   2                      //IMSI号 15字节 48
 1258   2                      //NB_CIMI(2);
 1259   2                      //SNR 值 2字节 50
 1260   2                      //NB_NUESTATS(2);
 1261   2                      //PCI 值 2字节 51 52
 1262   2      
 1263   2                      //校验位
 1264   2                      usMBCRC16(&C_DATA[2],25);
 1265   2                      C_DATA[53]=ucCRCLo;
 1266   2                      C_DATA[54]=ucCRCHi;
 1267   2                      //字尾
 1268   2                      C_DATA[55]=0X68;
 1269   2                      C_DATA[56]=0X16;
 1270   2                      break;
 1271   2              case 3://写指令返回
 1272   2                      C_DATA[6]=TX_Flag;
 1273   2                      C_DATA[7]=g_write_value[0];
 1274   2                      C_DATA[8]=g_write_value[1];
 1275   2                      C_DATA[9]=g_write_value[2];
 1276   2                      C_DATA[10]=g_write_value[3];
 1277   2                      C_DATA[11]=g_write_value[4];
 1278   2                      C_DATA[12]=g_write_value[5];
 1279   2                      C_DATA[13]=g_write_value[6];
 1280   2                      C_DATA[14]=0x00;
 1281   2                      C_DATA[15]=0x01;
 1282   2                      C_DATA[16]=Read_Flag;
 1283   2                      usMBCRC16(&C_DATA[2],15);
 1284   2                      C_DATA[17]=ucCRCLo;
 1285   2                      C_DATA[18]=ucCRCHi;
 1286   2                      C_DATA[19]=0X68;
 1287   2                      C_DATA[20]=0X16;
 1288   2                      break;
 1289   2              case 4://参数读取
 1290   2                      C_DATA[6]=0xA6;
 1291   2                      C_DATA[7]=g_write_value[0];
 1292   2                      C_DATA[8]=g_write_value[1];
 1293   2                      C_DATA[9]=g_write_value[2];
 1294   2                      C_DATA[10]=g_write_value[3];
 1295   2                      C_DATA[11]=g_write_value[4];
 1296   2                      C_DATA[12]=g_write_value[5];
 1297   2                      C_DATA[13]=g_write_value[6];
 1298   2                      C_DATA[14]=0x00;
 1299   2                      C_DATA[15]=0x02;
 1300   2                      C_DATA[16]=g_write_value[22]&0x80;
 1301   2                      C_DATA[17]=g_write_value[27];
 1302   2                      usMBCRC16(&C_DATA[2],16);
 1303   2                      C_DATA[18]=ucCRCLo;
 1304   2                      C_DATA[19]=ucCRCHi;
 1305   2                      C_DATA[20]=0X68;
 1306   2                      C_DATA[21]=0X16;
 1307   2                      break;
 1308   2              case 6://IP及端口读取
 1309   2                      C_DATA[6]=0xAB;
 1310   2                      C_DATA[7]=g_write_value[0];
 1311   2                      C_DATA[8]=g_write_value[1];
 1312   2                      C_DATA[9]=g_write_value[2];
 1313   2                      C_DATA[10]=g_write_value[3];
C251 COMPILER V5.04b,  Uart                                                                25/08/18  14:15:50  PAGE 21  

 1314   2                      C_DATA[11]=g_write_value[4];
 1315   2                      C_DATA[12]=g_write_value[5];
 1316   2                      C_DATA[13]=g_write_value[6];
 1317   2                      C_DATA[14]=0x00;
 1318   2                      C_DATA[15]=0x09;
 1319   2                      
 1320   2                      C_DATA[16] =g_write_value[28];
 1321   2                      C_DATA[17]=g_write_value[29];
 1322   2                      C_DATA[18]=g_write_value[30];
 1323   2                      C_DATA[19]=g_write_value[31];
 1324   2                      C_DATA[20]=g_write_value[32];
 1325   2                      C_DATA[21]=g_write_value[33];
 1326   2      
 1327   2                      C_DATA[22]=g_write_value[34];
 1328   2                      
 1329   2                      C_DATA[23]=g_write_value[35];
 1330   2                      C_DATA[24]=g_write_value[36];
 1331   2                      
 1332   2                      usMBCRC16(&C_DATA[2],24);
 1333   2                      C_DATA[25]=ucCRCLo;
 1334   2                      C_DATA[27]=ucCRCHi;
 1335   2                      C_DATA[28]=0x68;
 1336   2                      C_DATA[29]=0x16;
 1337   2                      break;
 1338   2              case 7://冻结数据上传 前10条  1-10
 1339   2                      C_DATA[6]=0xAF;
 1340   2                      C_DATA[7]=g_write_value[0];
 1341   2                      C_DATA[8]=g_write_value[1];
 1342   2                      C_DATA[9]=g_write_value[2];
 1343   2                      C_DATA[10]=g_write_value[3];
 1344   2                      C_DATA[11]=g_write_value[4];
 1345   2                      C_DATA[12]=g_write_value[5];
 1346   2                      C_DATA[13]=g_write_value[6];
 1347   2                      C_DATA[14]=0x00;
 1348   2                      if(g_write_value[20]>10) C_DATA[15]=70;
 1349   2                      else C_DATA[15]=g_write_value[20]*7;
 1350   2                      for(i=0;i<C_DATA[15];i++)//冻结数据转换
 1351   2                      C_DATA[i+16]=meter_data[i];
 1352   2                      C_DATA[15]=C_DATA[15]+1;
 1353   2                      C_DATA[15+C_DATA[15]]=g_write_value[27];
 1354   2                      //校验位
 1355   2                      usMBCRC16(&C_DATA[2],14+C_DATA[15]);
 1356   2                      C_DATA[16+C_DATA[15]]=ucCRCLo;
 1357   2                      C_DATA[17+C_DATA[15]]=ucCRCHi;
 1358   2                      //字尾
 1359   2                      C_DATA[18+C_DATA[15]]=0X68;
 1360   2                      C_DATA[19+C_DATA[15]]=0X16;
 1361   2                      break;
 1362   2              case 8://冻结数据上传 第二个10条 11-20
 1363   2                      C_DATA[6]=0xAF;
 1364   2                      C_DATA[7]=g_write_value[0];
 1365   2                      C_DATA[8]=g_write_value[1];
 1366   2                      C_DATA[9]=g_write_value[2];
 1367   2                      C_DATA[10]=g_write_value[3];
 1368   2                      C_DATA[11]=g_write_value[4];
 1369   2                      C_DATA[12]=g_write_value[5];
 1370   2                      C_DATA[13]=g_write_value[6];
 1371   2                      C_DATA[14]=0x00;
 1372   2                      if(g_write_value[20]>20) C_DATA[15]=70;
 1373   2                      else C_DATA[15]=(g_write_value[20]-10)*7;
 1374   2                      for(i=0;i<C_DATA[15];i++)//冻结数据转换
 1375   2                      C_DATA[16+i]=meter_data[i+70];//i-9+70
 1376   2                      C_DATA[15]=C_DATA[15]+1;
 1377   2                      C_DATA[15+C_DATA[15]]=g_write_value[27];
 1378   2                      //校验位
 1379   2                      usMBCRC16(&C_DATA[2],14+C_DATA[15]);
C251 COMPILER V5.04b,  Uart                                                                25/08/18  14:15:50  PAGE 22  

 1380   2                      C_DATA[16+C_DATA[15]]=ucCRCLo;
 1381   2                      C_DATA[17+C_DATA[15]]=ucCRCHi;
 1382   2                      //字尾
 1383   2                      C_DATA[18+C_DATA[15]]=0X68;
 1384   2                      C_DATA[19+C_DATA[15]]=0X16;
 1385   2                      break;
 1386   2              case 9://冻结数据上传 第三个10条  21-30
 1387   2                      C_DATA[6]=0xAF;
 1388   2                      C_DATA[7]=g_write_value[0];
 1389   2                      C_DATA[8]=g_write_value[1];
 1390   2                      C_DATA[9]=g_write_value[2];
 1391   2                      C_DATA[10]=g_write_value[3];
 1392   2                      C_DATA[11]=g_write_value[4];
 1393   2                      C_DATA[12]=g_write_value[5];
 1394   2                      C_DATA[13]=g_write_value[6];
 1395   2                      C_DATA[14]=0x00;
 1396   2                      if(g_write_value[20]>30) C_DATA[15]=70;
 1397   2                      else C_DATA[15]=(g_write_value[20]-20)*7;
 1398   2                      for(i=0;i<C_DATA[15];i++)//冻结数据转换
 1399   2                      C_DATA[16+i]=meter_data[i+140];//i-9+70
 1400   2                      C_DATA[15]=C_DATA[15]+1;
 1401   2                      C_DATA[15+C_DATA[15]]=g_write_value[27];
 1402   2                      //校验位
 1403   2                      usMBCRC16(&C_DATA[2],14+C_DATA[15]);
 1404   2                      C_DATA[16+C_DATA[15]]=ucCRCLo;
 1405   2                      C_DATA[17+C_DATA[15]]=ucCRCHi;
 1406   2                      //字尾
 1407   2                      C_DATA[18+C_DATA[15]]=0X68;
 1408   2                      C_DATA[19+C_DATA[15]]=0X16;
 1409   2                      break;
 1410   2              case 10://冻结数据上传 第四个10条 31-40
 1411   2                      C_DATA[6]=0xAF;
 1412   2                      C_DATA[7]=g_write_value[0];
 1413   2                      C_DATA[8]=g_write_value[1];
 1414   2                      C_DATA[9]=g_write_value[2];
 1415   2                      C_DATA[10]=g_write_value[3];
 1416   2                      C_DATA[11]=g_write_value[4];
 1417   2                      C_DATA[12]=g_write_value[5];
 1418   2                      C_DATA[13]=g_write_value[6];
 1419   2                      C_DATA[14]=0x00;
 1420   2                      if(g_write_value[20]>40) C_DATA[15]=70;
 1421   2                      else C_DATA[15]=(g_write_value[20]-30)*7;
 1422   2                      for(i=0;i<C_DATA[15];i++)//冻结数据转换
 1423   2                      C_DATA[16+i]=meter_data[i+210];//i-9+70
 1424   2                      C_DATA[15]=C_DATA[15]+1;
 1425   2                      C_DATA[15+C_DATA[15]]=g_write_value[27];
 1426   2                      //校验位
 1427   2                      usMBCRC16(&C_DATA[2],14+C_DATA[15]);
 1428   2                      C_DATA[16+C_DATA[15]]=ucCRCLo;
 1429   2                      C_DATA[17+C_DATA[15]]=ucCRCHi;
 1430   2                      //字尾
 1431   2                      C_DATA[18+C_DATA[15]]=0X68;
 1432   2                      C_DATA[19+C_DATA[15]]=0X16;
 1433   2                      break;
 1434   2              case 11://冻结数据上传 第五个10条 41-48
 1435   2                      C_DATA[6]=0xAF;
 1436   2                      C_DATA[7]=g_write_value[0];
 1437   2                      C_DATA[8]=g_write_value[1];
 1438   2                      C_DATA[9]=g_write_value[2];
 1439   2                      C_DATA[10]=g_write_value[3];
 1440   2                      C_DATA[11]=g_write_value[4];
 1441   2                      C_DATA[12]=g_write_value[5];
 1442   2                      C_DATA[13]=g_write_value[6];
 1443   2                      C_DATA[14]=0x00;
 1444   2                      if(g_write_value[20]>50) C_DATA[15]=70;
 1445   2                      else C_DATA[15]=(g_write_value[20]-40)*7;
C251 COMPILER V5.04b,  Uart                                                                25/08/18  14:15:50  PAGE 23  

 1446   2                      for(i=0;i<C_DATA[15];i++)//冻结数据转换
 1447   2                      C_DATA[16+i]=meter_data[i+280];//i-9+70
 1448   2                      C_DATA[15]=C_DATA[15]+1;
 1449   2                      C_DATA[15+C_DATA[15]]=g_write_value[27];
 1450   2                      //校验位
 1451   2                      usMBCRC16(&C_DATA[2],14+C_DATA[15]);
 1452   2                      C_DATA[16+C_DATA[15]]=ucCRCLo;
 1453   2                      C_DATA[17+C_DATA[15]]=ucCRCHi;
 1454   2                      //字尾
 1455   2                      C_DATA[18+C_DATA[15]]=0X68;
 1456   2                      C_DATA[19+C_DATA[15]]=0X16;
 1457   2                      break;          
 1458   2              }
 1459   1              if(RX0_flag==1)  
 1460   1              {
 1461   2                      TX_Flag=num;j=0;SBUF=C_DATA[j];
 1462   2                      
 1463   2                      while(TX_Flag);
 1464   2              } 
 1465   1              else NB_NSOST(C_DATA,num,5);
 1466   1      }
 1467          /*******************************************************************************
 1468          * 函  数  名      : RX_Judge
 1469          * 描      述      : 协议处理
 1470          * 输      入      : NULL 
 1471          * 返      回      : NULL
 1472          *******************************************************************************/
 1473          void RX_Judge(void)
 1474          {
 1475   1              uint8_t i;
 1476   1              if(C_DATA[0]==0x1B && C_DATA[1]==0x06 && ((C_DATA[2]==g_write_value[0] && C_DATA[3]==g_write_valu
             -e[1] && C_DATA[4]==g_write_value[2] && C_DATA[5]==g_write_value[3]
 1477   1                       && C_DATA[6]==g_write_value[4] && C_DATA[7]==g_write_value[5] && C_DATA[8]==g_write_value[6])
 1478   1              || (C_DATA[2]==0xAA && C_DATA[3]==0xAA && C_DATA[4]==0xAA && C_DATA[5]==0XAA && C_DATA[6]==0XAA && C_DAT
             -A[7]==0XAA && C_DATA[8]==0XAA))) //地址识别
 1479   1              {
 1480   2                      if(C_DATA[9]==0x41 && C_DATA[10]==0x10 && C_DATA[11]==0x00 && C_DATA[12]==0x00 && C_DATA[13]==0x00)//休
             -眠指令
 1481   2                      {
 1482   3                              usMBCRC16(&C_DATA[2],12);
 1483   3                              if(C_DATA[14]==ucCRCLo && C_DATA[15]==ucCRCHi)
 1484   3                          {   
 1485   4                              Data_deal(0,20);
 1486   4                              CDMA_Wait=100;
 1487   4                              }
 1488   3                      }
 1489   2                      if(C_DATA[9]==0x42 && C_DATA[10]==0x10 && C_DATA[11]==0x00 && C_DATA[12]==0x00 && C_DATA[13]==0x00)//数
             -据上传指令
 1490   2                      {
 1491   3                              usMBCRC16(&C_DATA[2],12);
 1492   3                              if(C_DATA[14]==ucCRCLo && C_DATA[15]==ucCRCHi)
 1493   3                              {
 1494   4                              Data_deal(1,57);
 1495   4                              }
 1496   3                      }
 1497   2                      if(C_DATA[9]==0x4C && C_DATA[10]==0x10 && C_DATA[11]==0x00 && C_DATA[12]==0x00 && C_DATA[13]==0x07)//写
             -表上时间
 1498   2                      {
 1499   3                              usMBCRC16(&C_DATA[2],19);
 1500   3                              if(C_DATA[21]==ucCRCLo && C_DATA[22]==ucCRCHi)
 1501   3                              {
 1502   4                                      g_write_value[13]=C_DATA[14];
 1503   4                                      g_write_value[14]=C_DATA[15];
 1504   4                                      g_write_value[15]=C_DATA[16];
 1505   4                                      g_write_value[16]=C_DATA[17];
 1506   4                                      g_write_value[17]=C_DATA[18];
C251 COMPILER V5.04b,  Uart                                                                25/08/18  14:15:50  PAGE 24  

 1507   4                                      g_write_value[18]=C_DATA[19];
 1508   4                                      g_write_value[19]=C_DATA[20];
 1509   4                                      RTCSet();
 1510   4                                      Read_Flag=0x00;
 1511   4                                      TX_Flag=0xAC;
 1512   4                                      Data_deal(3,21);        
 1513   4                              }
 1514   3                      }
 1515   2                      if(C_DATA[9]==0x43 && C_DATA[10]==0x10 && C_DATA[11]==0x00 && C_DATA[12]==0x00 && C_DATA[13]==0x01)//阀
             -门控制指令
 1516   2                      {
 1517   3                              usMBCRC16(&C_DATA[2],13);
 1518   3                              if(C_DATA[15]==ucCRCLo && C_DATA[16]==ucCRCHi)
 1519   3                              {
 1520   4                                       i=C_DATA[14];
 1521   4                                       Read_Flag=0x00;
 1522   4                                       TX_Flag=0xA3;                                                      
 1523   4                                   Data_deal(3,21);
 1524   4                                       if(i==0x55)//开阀
 1525   4                                       {
 1526   5                                              FCtrol(0);
 1527   5                                      }
 1528   4                                       else if(i==0x99)//关阀
 1529   4                                       {
 1530   5                                              FCtrol(1);
 1531   5                                       }
 1532   4                                       TX_Flag=0x67;                                                      
 1533   4                                   Data_deal(1,57);
 1534   4                                       LCDRAM3=LCDRAM5=LCDRAM7=0x40;
 1535   4                              }
 1536   3                      }
 1537   2                      if(C_DATA[9]==0x44 && C_DATA[10]==0x10 && C_DATA[11]==0x00 && C_DATA[12]==0x00 && C_DATA[13]==0x02)//参
             -数设置
 1538   2                      {
 1539   3                              usMBCRC16(&C_DATA[2],14);
 1540   3                              if(C_DATA[16]==ucCRCLo && C_DATA[17]==ucCRCHi)
 1541   3                              {
 1542   4                                      if(C_DATA[14]==0x00)
 1543   4                                      {
 1544   5                                               if((g_write_value[22]>>7)==0)
 1545   5                                               {
 1546   6                                                       g_write_value[27]=C_DATA[15];
 1547   6                                                       Read_Flag=0x00;
 1548   6                                               }
 1549   5                                               else
 1550   5                                               {
 1551   6                                                      Read_Flag=0x11;
 1552   6                                               }
 1553   5                                      }
 1554   4                                      else if(C_DATA[14]==0x80)
 1555   4                                      {
 1556   5                                                g_write_value[22] |=C_DATA[15];
 1557   5                                                g_write_value[27]=C_DATA[16];
 1558   5                                                Read_Flag=0x00;
 1559   5                                      }
 1560   4                                      else if(C_DATA[14]==0x88)//恢复出厂
 1561   4                                      {
 1562   5                                                g_write_value[22] &=~0x80;
 1563   5                                                g_write_value[7]=0x00;//用水量清零
 1564   5                                                g_write_value[8]=0x00;
 1565   5                                                g_write_value[9]=0x00;
 1566   5                                                Read_Flag=0x22;
 1567   5                                      }
 1568   4                                      //数据存储
 1569   4                                      Write_SegC();
 1570   4                                      TX_Flag=0xA4;
C251 COMPILER V5.04b,  Uart                                                                25/08/18  14:15:50  PAGE 25  

 1571   4                                      Data_deal(3,21);
 1572   4                              }
 1573   3                      }
 1574   2                      if(C_DATA[9]==0x46 && C_DATA[10]==0x10 && C_DATA[11]==0x00 && C_DATA[12]==0x00 && C_DATA[13]==0x00)//读
             -参数 
 1575   2                      {
 1576   3                              usMBCRC16(&C_DATA[2],12);
 1577   3                              if(C_DATA[14]==ucCRCLo && C_DATA[15]==ucCRCHi)
 1578   3                              {
 1579   4                                      Data_deal(4,22);
 1580   4                              }
 1581   3                      }
 1582   2                      if(C_DATA[9]==0x47 && C_DATA[10]==0x10 && C_DATA[11]==0x00 && C_DATA[12]==0x00 && C_DATA[13]==0x00)//读
             -程序版本
 1583   2                      {
 1584   3                              usMBCRC16(&C_DATA[2],12);
 1585   3                              if(C_DATA[14]==ucCRCLo && C_DATA[15]==ucCRCHi)
 1586   3                              {
 1587   4                                       Read_Flag=g_write_value[47];
 1588   4                                       TX_Flag=0xA7;
 1589   4                                   Data_deal(3,21);
 1590   4                              }
 1591   3                      }
 1592   2                      if(C_DATA[9]==0x48 && C_DATA[10]==0x10 && C_DATA[11]==0x00 && C_DATA[12]==0x00 && C_DATA[13]==0x00)//读
             -表地址
 1593   2                      {
 1594   3                              usMBCRC16(&C_DATA[2],12);
 1595   3                              if(C_DATA[14]==ucCRCLo && C_DATA[15]==ucCRCHi)
 1596   3                              {
 1597   4                                       Read_Flag=0x00;
 1598   4                                       TX_Flag=0xA8;
 1599   4                                       Data_deal(3,21);
 1600   4                              }
 1601   3                      }
 1602   2                      if(C_DATA[9]==0x49 && C_DATA[10]==0x10 && C_DATA[11]==0x00 && C_DATA[12]==0x00 && C_DATA[13]==0x07)//写
             -表地址
 1603   2                      {
 1604   3                              usMBCRC16(&C_DATA[2],19);
 1605   3                              if(C_DATA[21]==ucCRCLo && C_DATA[22]==ucCRCHi)
 1606   3                              {
 1607   4                                      g_write_value[0]=C_DATA[14];
 1608   4                                      g_write_value[1]=C_DATA[15];
 1609   4                                      g_write_value[2]=C_DATA[16];
 1610   4                                      g_write_value[3]=C_DATA[17];
 1611   4                                      g_write_value[4]=C_DATA[18];
 1612   4                                      g_write_value[5]=C_DATA[19];
 1613   4                                      g_write_value[6]=C_DATA[20];
 1614   4                                      //数据存储
 1615   4                                      Write_SegC();
 1616   4                                      Read_Flag=0x00;
 1617   4                                      TX_Flag=0xA9;
 1618   4                                      Data_deal(3,21);
 1619   4                              }
 1620   3                      } 
 1621   2                      if(C_DATA[9]==0x4A && C_DATA[10]==0x10 && C_DATA[11]==0x00 && C_DATA[12]==0x00 && C_DATA[13]==0x06)//设
             -置IP&Port
 1622   2                      {
 1623   3                              usMBCRC16(&C_DATA[2],18);
 1624   3                              if(C_DATA[20]==ucCRCLo && C_DATA[21]==ucCRCHi)
 1625   3                              {       //IP信息
 1626   4                                      g_write_value[28]=C_DATA[14];
 1627   4                                      g_write_value[29]=C_DATA[15];
 1628   4                                      g_write_value[30]=C_DATA[16];
 1629   4                                      g_write_value[31]=C_DATA[17];
 1630   4                                      g_write_value[32]=C_DATA[18];
 1631   4                                      g_write_value[33]=C_DATA[19];
C251 COMPILER V5.04b,  Uart                                                                25/08/18  14:15:50  PAGE 26  

 1632   4                                      //数据存储
 1633   4                                      Write_SegC(); 
 1634   4                                      Read_Flag=0x00;
 1635   4                                      TX_Flag=0xAA;
 1636   4                                      Data_deal(3,21);
 1637   4                              }
 1638   3                      }
 1639   2                      if(C_DATA[9]==0x4B && C_DATA[10]==0x10 && C_DATA[11]==0x00 && C_DATA[12]==0x00 && C_DATA[13]==0x00)//读
             -IP及端口
 1640   2                      {
 1641   3                              usMBCRC16(&C_DATA[2],12);
 1642   3                              if(C_DATA[14]==ucCRCLo && C_DATA[15]==ucCRCHi)//CDMA
 1643   3                              {
 1644   4                                       Data_deal(6,37);
 1645   4                              }
 1646   3                      }
 1647   2                      if(C_DATA[9]==0x4D && C_DATA[10]==0x10 && C_DATA[11]==0x00 && C_DATA[12]==0x00 && C_DATA[13]==0x01 && C
             -_DATA[14]==0x11)//故障位清除
 1648   2                      {
 1649   3                              usMBCRC16(&C_DATA[2],13);
 1650   3                              if(C_DATA[15]==ucCRCLo && C_DATA[16]==ucCRCHi)
 1651   3                              {
 1652   4                                      g_write_value[22]&=0x83;//清除故障位
 1653   4                                      g_write_value[23]&=~0xE0;
 1654   4                                      //数据存储
 1655   4                                      Write_SegC();          
 1656   4                                  FDcycflag=1;  
 1657   4                                      flagtype &=~0x80; 
 1658   4                                  flagtype &=~0x0C;       
 1659   4                                  flagtype |= 0x02;      
 1660   4       
 1661   4                                      //清除液晶显示    
 1662   4                                  //LCDRAM13 &=~(BIT1+BIT2+BIT6); 
 1663   4                                      //LCDRAM12 &=~BIT5;  
 1664   4                                      Read_Flag=0x00;
 1665   4                                      TX_Flag=0xAD;
 1666   4                                      Data_deal(3,21);
 1667   4                              }
 1668   3                      }
 1669   2                      if(C_DATA[9]==0x4E && C_DATA[10]==0x10 && C_DATA[11]==0x00 && C_DATA[12]==0x00 && C_DATA[13]==0x03)//设
             -置上报周期和时间
 1670   2                      {
 1671   3                              usMBCRC16(&C_DATA[2],15);
 1672   3                              if(C_DATA[17]==ucCRCLo && C_DATA[18]==ucCRCHi)
 1673   3                              {
 1674   4                                  //上传间隔 hex
 1675   4                                      g_write_value[34]=C_DATA[14];
 1676   4                                      //定时上传时间 时 分  BCD码        
 1677   4                                      g_write_value[35]=C_DATA[15];
 1678   4                                      g_write_value[36]=C_DATA[16];
 1679   4                                      date=mem_date=0;
 1680   4                                      RNG_Time();
 1681   4                                      Write_SegC();
 1682   4                                      Read_Flag=0x00;
 1683   4                                      TX_Flag=0xAE;
 1684   4                                      Data_deal(3,21);
 1685   4                              }
 1686   3                      }
 1687   2                      if(C_DATA[9]==0x4F && C_DATA[10]==0x10 && C_DATA[11]==0x00 && C_DATA[12]==0x00 && C_DATA[13]==0x00)//确
             -认读取冻结数据成功
 1688   2                      {
 1689   3                              usMBCRC16(&C_DATA[2],12);
 1690   3                              if(C_DATA[14]==ucCRCLo && C_DATA[15]==ucCRCHi)
 1691   3                              {
 1692   4                                       g_write_value[46]=2;
 1693   4                                       g_write_value[20]=0; 
C251 COMPILER V5.04b,  Uart                                                                25/08/18  14:15:50  PAGE 27  

 1694   4                                       Write_SegC();
 1695   4                                       Read_Flag=0x22;
 1696   4                                       TX_Flag=0xB0;
 1697   4                                   Data_deal(3,21);
 1698   4                              }
 1699   3                      }
 1700   2                      if(C_DATA[9]==0x45 && C_DATA[10]==0x10 && C_DATA[11]==0x00 && C_DATA[12]==0x00 && C_DATA[13]==0x03)//写
             -表底数
 1701   2                      {
 1702   3                              usMBCRC16(&C_DATA[2],15);
 1703   3                              if(C_DATA[17]==ucCRCLo && C_DATA[18]==ucCRCHi)
 1704   3                              {
 1705   4                                      g_write_value[7]=C_DATA[14];   
 1706   4                                      g_write_value[8]=C_DATA[15];
 1707   4                                      g_write_value[9]=C_DATA[16];
 1708   4                                      Write_SegC();
 1709   4                                      Read_Flag=0x00;
 1710   4                                      TX_Flag=0xA5;
 1711   4                                      Data_deal(3,21);
 1712   4                              }
 1713   3                      }
 1714   2                      for(i=0;i<100;i++)
 1715   2                      {
 1716   3                              C_DATA[i]=0;
 1717   3                      }
 1718   2                      Clear_RX(0);
 1719   2                      y=0;
 1720   2              }
 1721   1              InitData();
 1722   1      }
 1723          /*******************************************************************************
 1724          * 函  数  名      : NB_RX
 1725          * 描      述      : NB模块接收数据处理
 1726          * 输      入      : time 等待返回的时间  
 1727          * 返      回      : 执行结果 1 OK  0 err
 1728          +NNMI:4,AAAA0000
 1729          *******************************************************************************/
 1730          void NB_RX(void)
 1731          {
 1732   1              uint8_t i,n,a,b,temp,num;
 1733   1              for(i=0;i<50;i++)
 1734   1              if(RX0[i]=='A' && RX0[i+1]=='T' && RX0[i+2]=='A' && RX0[i+3]==':')//查询是否有接收到数据
 1735   1              {
 1736   2                      CDMA_time=1;
 1737   2                      while(CDMA_time);
 1738   2                      temp=1;
 1739   2                      break;
 1740   2              }               
 1741   1           if(temp)//接收到数据
 1742   1              {
 1743   2                      temp=0;
 1744   2                      a=Check_Str(',');//找到数据位置
 1745   2                      b=Check_Str(':');
 1746   2                      n=a-b-1;
 1747   2                      if(n==1)
 1748   2                      {
 1749   3                              num=RX0[a-1]-0x30;
 1750   3                      }
 1751   2                      else if(n==2)
 1752   2                      {
 1753   3                              num=RX0[a-1]-0x30;
 1754   3                              num=(RX0[a-2]-0x30)*10+num;
 1755   3                      }
 1756   2                      else if(n==3)
 1757   2                      {
 1758   3                              num=RX0[a-1]-0x30;
C251 COMPILER V5.04b,  Uart                                                                25/08/18  14:15:50  PAGE 28  

 1759   3                              num=(RX0[a-2]-0x30)*10+num;
 1760   3                              num=num+(RX0[a-3]-0x30)*100; //num接收的字节数
 1761   3                      }
 1762   2                      n=a;
 1763   2                      //协议转换
 1764   2                              for(i=0;i<num;i++)
 1765   2                              {
 1766   3                                      a=RX0[n+1+i*2];
 1767   3                                  b=RX0[n+2+i*2];
 1768   3                                      if(a>0x40)
 1769   3                                      {                  
 1770   4                                              if(a==0x41) a=10;
 1771   4                                              if(a==0x42) a=11;
 1772   4                                              if(a==0x43) a=12;
 1773   4                                              if(a==0x44) a=13;
 1774   4                                              if(a==0x45) a=14;
 1775   4                                              if(a==0x46) a=15;
 1776   4                                      }
 1777   3                                      else a=a-0x30;
 1778   3                                      if(b>0x40)
 1779   3                                      {
 1780   4                                              if(b==0x41) b=10;
 1781   4                                              if(b==0x42) b=11;
 1782   4                                              if(b==0x43) b=12;
 1783   4                                              if(b==0x44) b=13;
 1784   4                                              if(b==0x45) b=14;
 1785   4                                              if(b==0x46) b=15;
 1786   4                                      }
 1787   3                                      else b=b-0x30;
 1788   3                                      C_DATA[i]=a*16+b;
 1789   3                              }
 1790   2                              RX_Judge();     //协议判断              
 1791   2              }
 1792   1              else
 1793   1              {
 1794   2                      if(RX0[99]!=0)
 1795   2                      {
 1796   3                               Clear_RX(0);
 1797   3                               y=0;
 1798   3                      }
 1799   2              }
 1800   1      }
 1801          /*******************************************************************************
 1802          * 函  数  名      : NB_Send
 1803          * 描      述      : NB模块上电，并等待工作正常
 1804          * 输      入      : time 等待返回的时间  
 1805          * 返      回      : 执行结果 1 OK  0 err
 1806          *******************************************************************************/
 1807          void NB_Send(void)
 1808          {
 1809   1              Uart_Init();_nop_();_nop_();
 1810   1          z=1;
 1811   1              LCDRAM3=LCDRAM5=LCDRAM7=0x40;
 1812   1              if(NB_Open(500))//开机成功
 1813   1              {       LCDRAM3=LCDRAM5=LCDRAM7=0x00;
 1814   2                      LCDRAM2=0xE6; 
 1815   2                      if(NB_IoT())
 1816   2                      {       
 1817   3                              if(NB_CSQ(50))//等待信号稳定
 1818   3                              {       LCDRAM4=0xE6; 
 1819   4                                      if(NB_CGATT(50))//是否附着成功
 1820   4                                      {       LCDRAM6=0xE6;
 1821   5                                              if(NB_CEREG(3))
 1822   5                                              {       LCDRAM10=0xE6;
 1823   6                                                      if(NB_NMGS(10))//发送一次数据，激活模组在线
 1824   6                                                      {       LCDRAM3=LCDRAM5=LCDRAM7=0x40;
C251 COMPILER V5.04b,  Uart                                                                25/08/18  14:15:50  PAGE 29  

 1825   7                                                              CDMA_time=1;
 1826   7                                                              while(CDMA_time);//等待关闭
 1827   7                                                              //IMSI号 15字节 48
 1828   7                                                              NB_CIMI(2);
 1829   7                                                              //SNR 值 2字节 50
 1830   7                                                              NB_NUESTATS(2);
 1831   7                                                              //PCI 值 2字节 51 52
 1832   7                                                              Data_deal(1,57);//发送实时数据
 1833   7                                                              CDMA_time=1;
 1834   7                                                              while(CDMA_time);//等待关闭
 1835   7                                                              Read_Flag=0x22;
 1836   7                                                              TX_Flag=0xB0;
 1837   7                                                      Data_deal(3,21);// 发送标志位 
 1838   7                                                              CDMA_Wait=0;
 1839   7                                                              y=0;
 1840   7                                                              while(CDMA_Wait<40) //在线等待25秒
 1841   7                                                              {                                                               
 1842   8                                                                      NB_RX();//等待数据接收  
 1843   8                                                              }
 1844   7                                                              NB_CFUN(0,15);                                                  
 1845   7                                                      }
 1846   6                                                      else
 1847   6                                                      {
 1848   7                                                              if(NB_CFUN(0,20))//关闭射频
 1849   7                                                              {
 1850   8                                                                      NB_NCSEARFCN(2);
 1851   8                                                                      CDMA_time=1;
 1852   8                                                                      while(CDMA_time);//等待关闭     
 1853   8                                                              }               
 1854   7                                                      }
 1855   6                                                      
 1856   6                                               } 
 1857   5                                      }
 1858   4                                      else
 1859   4                                      {
 1860   5                                              if(NB_CFUN(0,20))//关闭射频
 1861   5                                              {
 1862   6                                                      NB_NCSEARFCN(2);
 1863   6                                                      CDMA_time=1;
 1864   6                                                      while(CDMA_time);//等待关闭     
 1865   6                                              }
 1866   5                                              
 1867   5                                      }
 1868   4                              }
 1869   3                              else
 1870   3                              {
 1871   4                                      if(NB_CFUN(0,20))//关闭射频
 1872   4                                      {
 1873   5                                              NB_NCSEARFCN(2);
 1874   5                                              CDMA_time=1;
 1875   5                                              while(CDMA_time);//等待关闭     
 1876   5                                      }
 1877   4                                      
 1878   4                              }       
 1879   3                      }
 1880   2              }
 1881   1              NB_Close(1);
 1882   1          z=0; 
 1883   1      }
 1884          /*******************************************************************************
 1885          * 函  数  名      : NB_Send2
 1886          * 描      述      : NB 开机 设置参数
 1887          * 输      入      : time 等待返回的时间  
 1888          * 返      回      : 执行结果 1 OK  0 err
 1889          *******************************************************************************/
 1890          void NB_Send2(void)
C251 COMPILER V5.04b,  Uart                                                                25/08/18  14:15:50  PAGE 30  

 1891          {
 1892   1              Uart_Init();_nop_();_nop_();
 1893   1          z=1;
 1894   1              if(NB_Open(500))//开机成功
 1895   1              {        
 1896   2                      if(NB_CFUN(0,20))//关闭射频
 1897   2                       {                      
 1898   3                              if(NB_IoT_IP(600))//设置IoT IP
 1899   3                              {       
 1900   4                                      NB_IoT_123(500);
 1901   4                                      NB_IoT_124(8);
 1902   4                              }       
 1903   3      
 1904   3                       }              
 1905   2              }
 1906   1              NB_Close(1);
 1907   1          z=0;  
 1908   1      }
 1909          /*******************************************************************************
 1910          * 函  数  名      : Data_UP
 1911          * 描      述      : NB定时上传
 1912          * 输      入      : time 等待返回的时间  
 1913          * 返      回      : 执行结果 1 OK  0 err
 1914          *******************************************************************************/
 1915          void Data_UP(void)
 1916          {
 1917   1              unsigned char send_num=0;
 1918   1              //冻结数据上报
 1919   1              if(g_write_value[20]==0)
 1920   1              {
 1921   2                      Read_Flag=0x00;         
 1922   2              }
 1923   1              else if(g_write_value[20]<11)
 1924   1              {
 1925   2                      send_num=g_write_value[20]*7+21;
 1926   2                      Data_deal(7,send_num);//1-10条 
 1927   2                      Read_Flag=0x11; 
 1928   2              }
 1929   1              else if(g_write_value[20]<21)
 1930   1              {
 1931   2                      send_num=(g_write_value[20]-10)*7+21;
 1932   2                      Data_deal(7,91);//前10条
 1933   2                      CDMA_time=1;
 1934   2                      while(CDMA_time);//等待关闭     
 1935   2                      Data_deal(8,send_num);//11-20条 
 1936   2                      Read_Flag=0x11;
 1937   2              }
 1938   1              else if(g_write_value[20]<31)
 1939   1              {
 1940   2                      send_num=(g_write_value[20]-20)*7+21;
 1941   2                      Data_deal(7,91);//前10条
 1942   2                      CDMA_time=1;
 1943   2                      while(CDMA_time);//等待关闭     
 1944   2                      Data_deal(8,91);//前20条
 1945   2                      CDMA_time=1;
 1946   2                      while(CDMA_time);//等待关闭     
 1947   2                      Data_deal(9,send_num);//21-30条 
 1948   2                      Read_Flag=0x11;                                                 
 1949   2              }
 1950   1              else if(g_write_value[20]<41)
 1951   1              {
 1952   2                      send_num=(g_write_value[20]-30)*7+21;
 1953   2                      Data_deal(7,91);//前10条
 1954   2                      CDMA_time=1;
 1955   2                      while(CDMA_time);//等待关闭     
 1956   2                      Data_deal(8,91);//前20条
C251 COMPILER V5.04b,  Uart                                                                25/08/18  14:15:50  PAGE 31  

 1957   2                      CDMA_time=1;
 1958   2                      while(CDMA_time);//等待关闭     
 1959   2                      Data_deal(9,91);//前30条
 1960   2                      CDMA_time=1;
 1961   2                      while(CDMA_time);//等待关闭     
 1962   2                      Data_deal(10,send_num);//31-40条
 1963   2                      Read_Flag=0x11;                                                         
 1964   2              }
 1965   1              else if(g_write_value[20]<51)
 1966   1              {
 1967   2                      send_num=(g_write_value[20]-40)*7+21;
 1968   2                      Data_deal(7,91);//前10条
 1969   2                      CDMA_time=1;
 1970   2                      while(CDMA_time);//等待关闭     
 1971   2                      Data_deal(8,91);//前20条
 1972   2                      CDMA_time=2;
 1973   2                      while(CDMA_time);//等待关闭     
 1974   2                      Data_deal(9,91);//前30条
 1975   2                      CDMA_time=1;
 1976   2                      while(CDMA_time);//等待关闭     
 1977   2                      Data_deal(10,91);//前40条
 1978   2                      CDMA_time=1;
 1979   2                      while(CDMA_time);//等待关闭     
 1980   2                      Data_deal(11,send_num);//41-50条
 1981   2                      Read_Flag=0x11;                                                         
 1982   2              }
 1983   1              TX_Flag=0xB0;
 1984   1              Data_deal(3,21);        
 1985   1      }
 1986          /*******************************************************************************
 1987          * 函  数  名      : NB_Timing_Send
 1988          * 描      述      : NB定时上传
 1989          * 输      入      : time 等待返回的时间  
 1990          * 返      回      : 执行结果 1 OK  0 err
 1991          *******************************************************************************/
 1992          void NB_Timing_Send(void)
 1993          {
 1994   1              Uart_Init();_nop_();_nop_();
 1995   1          z=1;
 1996   1              if(NB_Open(500))//开机成功
 1997   1              {        
 1998   2                      if(NB_IoT())
 1999   2                      {
 2000   3                              if(NB_CSQ(50))//等待信号稳定
 2001   3                              {        
 2002   4                                      if(NB_CGATT(50))//是否附着成功
 2003   4                                      {       
 2004   5                                              if(NB_CEREG(3))
 2005   5                                              {
 2006   6                                                      if(NB_NMGS(10))//发送一次数据，激活模组上线
 2007   6                                                      {
 2008   7                                                              CDMA_time=1;
 2009   7                                                              while(CDMA_time);//等待关闭     
 2010   7                                                              //IMSI号 15字节 48
 2011   7                                                              NB_CIMI(2);
 2012   7                                                              //SNR 值 2字节 50
 2013   7                                                              NB_NUESTATS(2);
 2014   7                                                              //PCI 值 2字节 51 52
 2015   7                                                              //实时数据上报
 2016   7                                                              Data_deal(1,57);
 2017   7                                                              CDMA_time=1;
 2018   7                                                              while(CDMA_time);
 2019   7                                                              //冻结数据上报
 2020   7                                                              Data_UP();
 2021   7                                                              g_write_value[46]=1;//数据发送标志
 2022   7                                                              //等待数据
C251 COMPILER V5.04b,  Uart                                                                25/08/18  14:15:50  PAGE 32  

 2023   7                                                              CDMA_Wait=0;
 2024   7                                                              y=0;
 2025   7                                                              while(CDMA_Wait<30)
 2026   7                                                              {                                                               
 2027   8                                                                      NB_RX();//等待数据接收  
 2028   8                                                              }
 2029   7                                                              if(g_write_value[46]==1)//上线成功  但是没有接收到平台指令，重新发一次
 2030   7                                                              {
 2031   8                                                                      //IMSI号 15字节 48
 2032   8                                                                      NB_CIMI(2);
 2033   8                                                                      //SNR 值 2字节 50
 2034   8                                                                      NB_NUESTATS(2);
 2035   8                                                                      //PCI 值 2字节 51 52
 2036   8                                                                      //实时数据上报
 2037   8                                                                      Data_deal(1,57);
 2038   8                                                                      CDMA_time=1;
 2039   8                                                                      while(CDMA_time);
 2040   8                                                                      //冻结数据上报
 2041   8                                                                      Data_UP();
 2042   8                                                                      CDMA_Wait=0;
 2043   8                                                                      y=0;
 2044   8                                                                      while(CDMA_Wait<30)
 2045   8                                                                      {                                                               
 2046   9                                                                              NB_RX();//等待数据接收  
 2047   9                                                                      }
 2048   8                                                              }
 2049   7                                                              NB_CFUN(0,15);                                                  
 2050   7                                                      }
 2051   6                                                      else
 2052   6                                                      {
 2053   7                                                              if(NB_CFUN(0,20))//关闭射频
 2054   7                                                              {
 2055   8                                                                      NB_NCSEARFCN(2);
 2056   8                                                                      CDMA_time=1;
 2057   8                                                                      while(CDMA_time);//等待关闭     
 2058   8                                                              }                                                       
 2059   7                                                      }
 2060   6                                                      
 2061   6                                              }       
 2062   5                                      }
 2063   4                                      else
 2064   4                                      {
 2065   5                                              if(NB_CFUN(0,20))//关闭射频
 2066   5                                              {
 2067   6                                                      NB_NCSEARFCN(2);
 2068   6                                                      CDMA_time=1;
 2069   6                                                      while(CDMA_time);//等待关闭     
 2070   6                                              }
 2071   5                                      }
 2072   4                              }
 2073   3                              else
 2074   3                              {
 2075   4                                      if(NB_CFUN(0,20))//关闭射频
 2076   4                                      {
 2077   5                                              NB_NCSEARFCN(2);
 2078   5                                              CDMA_time=1;
 2079   5                                              while(CDMA_time);//等待关闭     
 2080   5                                      }
 2081   4                              }       
 2082   3                      }
 2083   2              }
 2084   1              NB_Close(1);
 2085   1          z=0;
 2086   1      }
 2087          /*******************************************************************************
 2088          * 函  数  名      : RX0_read
C251 COMPILER V5.04b,  Uart                                                                25/08/18  14:15:50  PAGE 33  

 2089          * 描      述      : 下行设置参数读取
 2090          * 输      入      : 无  
 2091          * 返      回      : 无
 2092          *******************************************************************************/
 2093          void RX0_read(void)
 2094          {
 2095   1              uchar i;
 2096   1              RX0_flag=0;z=0;
 2097   1              Uart0_Init();
 2098   1              CDMA_time=1;
 2099   1              while(CDMA_time);//等待接收时间 if(RX1_flag)
 2100   1              if(RX0_flag==1)
 2101   1              {               
 2102   2                      for(i=0;i<40;i++) C_DATA[i]=RX0[i];
 2103   2                      RX_Judge();
 2104   2                      for(i=0;i<40;i++) RX0[i]=0;
 2105   2                      RX0_flag=0;z=0;
 2106   2              }
 2107   1              showIP=0;
 2108   1              NB_Close(1);
 2109   1      }
 2110          //================================================
 2111          //UART中断       串口的奇偶校验均需软件实现
 2112          //================================================
 2113          void INTERRUPT_UART(void) interrupt 4
 2114          {
 2115   1      //------------------------------------------------
 2116   1              if(SCON & U0RI)                                                          //如果是U0接收中断     
 2117   1              {
 2118   2                  SCON &= ~U0RI;                                                       //清除接收中断标志
 2119   2                      RX0[z]=SBUF;
 2120   2                      if(RX0[0]==0x1B)
 2121   2                      {
 2122   3                              z++;
 2123   3                              if(z==(RX0[13]+16)) 
 2124   3                              RX0_flag=1;
 2125   3                              if(z>40) z=0;                   
 2126   3                      }
 2127   2              }
 2128   1      //------------------------------------------------
 2129   1              if(SCON & U0TI)                                                          //如果是U0发送中断
 2130   1              {
 2131   2                      SCON &= ~U0TI;  //清发送完成中断标志
 2132   2                      j++;                                                                     
 2133   2                  if (j < TX_Flag)  SBUF =C_DATA[j];             
 2134   2                  else TX_Flag=0;//表示发送完成 
 2135   2              }
 2136   1      //================================================
 2137   1      //UART1中断      串口的奇偶校验均需软件实现
 2138   1      //================================================
 2139   1              //------------------------------------------------
 2140   1              if(SCON1 & U1RI)                                                                 //如果是U1接收中断
 2141   1              {
 2142   2                      SCON1 &= ~U1RI;
 2143   2                      RX0[y]=SBUF1;
 2144   2                      y++;
 2145   2                      if(y>150) y=0;
 2146   2              }
 2147   1      //------------------------------------------------
 2148   1              if(SCON1 & U1TI)                                                                 //如果是U1发送中断
 2149   1              {       
 2150   2                      SCON1 &= ~U1TI;
 2151   2                      j++;                                                                     
 2152   2                  if (j < TX_Flag)  SBUF1 =TX[j];             
 2153   2                  else TX_Flag=0;//表示发送完成 
 2154   2              }
C251 COMPILER V5.04b,  Uart                                                                25/08/18  14:15:50  PAGE 34  

 2155   1      
 2156   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      9357     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       409          5
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       750     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
